[1,["1brw/JvvpFnIvdrxpFCgMZ","d3x4IMKphEKYvHuEU7yaxB","12Y9dMgWdJKJGmTiZyQR9H@a804a","8f94dJg0VFxJIqXv7mGVQZ@f9941","e9Q9HM+MhADY6FSxQKbbM4@f9941","f43AMOuB5DRqTUFhRHrEvd","3flS2QI/9MyIiQzatYWhKS","59tFDfmg5Phprv4Ib/8pRh@d9f7e","7dj5uJT9FMn6OrOOx83tfK@f9941","9fgpXGXotLYJD/CBLlWkzV","24KRWE4ehKK6RdvOqGmlra@1f586","12Y9dMgWdJKJGmTiZyQR9H@2e76e","59tFDfmg5Phprv4Ib/8pRh@b0b8b","59tFDfmg5Phprv4Ib/8pRh@3905e","59tFDfmg5Phprv4Ib/8pRh@c75fc","a3zQCfCrBCDZJ4uf2rk5u8","22uA5Qv8JHY6igdVT2pJ/Z@22c86","22uA5Qv8JHY6igdVT2pJ/Z@30732","63n42MtdBHR4I91ZIsRK7G@cf5ee","33IxBIaABALZals4tKg5kO@4a784","17Ve8OT3xHv5YAWBeWLOSu@b7e8c","46tpMo+GlFS4VIaVKjpXCx@8eeb8","70gCn+RRFMfqRhe81JEl7p@f9941","f1VLQ6c/RFgIA2malFARFv@f9941","deavVa2FRDhZgOrTd7ML8d@f9941","59tFDfmg5Phprv4Ib/8pRh@12fbe","59tFDfmg5Phprv4Ib/8pRh@3982f","f7WD73YYpHpZSvabaw5wRF","56OAPizb5IhLDbGZdeRmeR@77746","afbKm1t6xMUpXEJZWiE0tS@77f86","6dkrifP3RBlaA3IOEAfhCy@781ff","5e9wWwHltBxJoFKGphTcbP@bad45","f9x+pxAi5EiYLMG7zzh/fs@8fa0e","29ClH+KQ1HRoryqI9WKwKQ@90479","8c+Y9TioJC250IhtI8qHDN@630b9","10X6a+2L5DdocYOSQfu2iq@4a2ae","59tFDfmg5Phprv4Ib/8pRh@aa14f","5fJ4kAVdxHCJ73hT/e/TlJ","1aS81TE3xNLaHr+V77FG5T","85/E+aBh1DKrlfnj6tNXps","c8PogrOyxA34UqftJj58Fs","edsxqRr9VG5ZBd1m4tHBbe","80gpRwle5GEIQjvNskW/Ah","04D6vZwgJJBbMRrl2oLZYl","b2QV29NB5BW42k0XCvjsF6","59tFDfmg5Phprv4Ib/8pRh@99716","5fQvgfqLlH/YTAMcAZf8Hg@6c48a","22uA5Qv8JHY6igdVT2pJ/Z@2dd28","22uA5Qv8JHY6igdVT2pJ/Z@1080a","22uA5Qv8JHY6igdVT2pJ/Z@f1394","86PHvnWSNKBZcOZO+Agjf5@29f8a","06DKEGyHdDSYV4uF3wN2em@0886b","fckek2X3JCf4lHNiaceXf+@99dea","6451Gg9UxPJ42uB+jhC/ME@3c3f9","35LncvZ5BJhJXstEzOAk7F@4bf0b","012vZJ1+5JSJRhGMOKyrb4@91c70","04aqFKj+hHyrR0F+XvmYiO@3936d","06bsNJ7XhCH47vxstqPesE@4133e","d5rVGXCbNBMoxiiTYhZ4RB@27e00","48zHeqr0BAJqO+O1PovCAy@41786","fdJRuzvYZBkZy9ieH8bLmC@f9941","2fBMkNxD9C5KkQOWeStvmz@f9941","72ZeP8FStB4aB9F226vCjN@f9941","4cBCNeHSZLRK4GrC2tMWP0@f9941","22uA5Qv8JHY6igdVT2pJ/Z@b2d6f","1f9uCE7zJI07T3zRPvmpAG@6c48a","f44JTznWRM6qnGCH+54piJ@6c48a","24+iSbl3dCdaM7+1tfbz8h@6c48a","2fBMkNxD9C5KkQOWeStvmz@6c48a","c1M7M9JZBPOYv/Hc6Ib6kb","4cBCNeHSZLRK4GrC2tMWP0@6c48a","57UgcWSMhKGYrPQcn4d3+w@6c48a","59tFDfmg5Phprv4Ib/8pRh@1b110","59tFDfmg5Phprv4Ib/8pRh@869d6","59tFDfmg5Phprv4Ib/8pRh@55313","59tFDfmg5Phprv4Ib/8pRh@206fe","59tFDfmg5Phprv4Ib/8pRh@16b53","59tFDfmg5Phprv4Ib/8pRh@04019","59tFDfmg5Phprv4Ib/8pRh@a0436","59tFDfmg5Phprv4Ib/8pRh@bfb67","59tFDfmg5Phprv4Ib/8pRh@e80b8","26/oaj56FGgoweGnBeMxGs","6eXcH7XzdEPIl4C8ujsNnj","65gMtjMX1Ac6J9W3Gnynkf@bcca5","70gCn+RRFMfqRhe81JEl7p@6c48a","72ZeP8FStB4aB9F226vCjN@6c48a","7dj5uJT9FMn6OrOOx83tfK@6c48a","cecRNBq1hCUbDVVYc4+gsX","10ApiVzQNAAK52t0zijz8V","c8bmkxyWtB/pMCkCJ4cmHj","68KfY1tHdAlq7+vGEAwvag@0aa4d","5aSpmxA21OC6HCP++UO4T3","4erimqOiFBYLd3BHGRdzfk","c4FLXYfoRAeZyeZ2n3Ozoi","e0ILlEmdhP4rbneyvK+2W0@00aac","e0ILlEmdhP4rbneyvK+2W0@438fe","59tFDfmg5Phprv4Ib/8pRh@b9a7d","8dvwgYlglHapBRreIIT39H","0bYyPIq+ZBsbl7Zkn2hDPS","a2Eg0/MR5N7aZyCEZtDN4d","basjTcsodN25qm6pMgv7cd","b9HJBtvz5KY5MdEDeIG2xr","19b0i5oIZJKYPt908O3LJq","57UgcWSMhKGYrPQcn4d3+w@f9941","ee0sYPMNtOaJk6omPMT1qE","6ex9RLOeZFjJw2NUz1dikd@6c48a","8f94dJg0VFxJIqXv7mGVQZ@6c48a","a4IPLq+GpL6KRnFlCKL6PW@6c48a","b6yRi5iUVN973wQTDjQ9gI@bf27e","8fdc6ja1xFO6HQgysEUOKz","21pziyMDNINYMc5uwG3ANY","c87krj6kNNbZ2ZHltZWhUZ","aaEOgZJLVJFpRNcSTAMcww","8fNvXhRIhJLJcv/z75odZE","a6swEvpwdOD70dNkHgqnyM","12iuvZ9jZGc63no68m4+Uq","91pAnuTXNGDIRnoeY37vdL","6eaiQWRMZCoZ0x0A0r+h67","ecU5rVwHpCkr/pI172Kh8c","e6reKq+e1KtaEkUQwJ4S5z","e6SliKjNBCMY9QkcY20bvB","93hy0KvVBFj4eflDwqJYHN","c4xsDhYvJHc4E4t9cDe5pZ@6c48a","d8s2ald4dJQoXlsItgkIhg@6c48a","59tFDfmg5Phprv4Ib/8pRh@f2dd9","59tFDfmg5Phprv4Ib/8pRh@62c1d","59tFDfmg5Phprv4Ib/8pRh@8a319","59tFDfmg5Phprv4Ib/8pRh@53398","59tFDfmg5Phprv4Ib/8pRh@6d19b","59tFDfmg5Phprv4Ib/8pRh@6fce7","59tFDfmg5Phprv4Ib/8pRh@6f128","59tFDfmg5Phprv4Ib/8pRh@7d412","59tFDfmg5Phprv4Ib/8pRh@1d0c0","59tFDfmg5Phprv4Ib/8pRh@7c5f4","59tFDfmg5Phprv4Ib/8pRh@696d0","59tFDfmg5Phprv4Ib/8pRh@3b002","59tFDfmg5Phprv4Ib/8pRh@d495f","59tFDfmg5Phprv4Ib/8pRh@71c4d","59tFDfmg5Phprv4Ib/8pRh@11f91","59tFDfmg5Phprv4Ib/8pRh@16ef1","59tFDfmg5Phprv4Ib/8pRh@bf4df","59tFDfmg5Phprv4Ib/8pRh@349f4","59tFDfmg5Phprv4Ib/8pRh@e288f","59tFDfmg5Phprv4Ib/8pRh@b9c52","59tFDfmg5Phprv4Ib/8pRh@a4d41","59tFDfmg5Phprv4Ib/8pRh@c3ed0","59tFDfmg5Phprv4Ib/8pRh@81def","59tFDfmg5Phprv4Ib/8pRh@afe66","59tFDfmg5Phprv4Ib/8pRh@f0000","59tFDfmg5Phprv4Ib/8pRh@f225d","b6yRi5iUVN973wQTDjQ9gI@d19b6","b6yRi5iUVN973wQTDjQ9gI@dc9a1","e0garo8TlIub9Zg0zltDDD@883aa","65gMtjMX1Ac6J9W3Gnynkf@2555d","deavVa2FRDhZgOrTd7ML8d@6c48a","26iej+Q9xJub1HzXJtKGZe","26e8nw5EZDRIxQtB385oNG","e0garo8TlIub9Zg0zltDDD@bcca5","e9Q9HM+MhADY6FSxQKbbM4@6c48a","f1VLQ6c/RFgIA2malFARFv@6c48a","fdJRuzvYZBkZy9ieH8bLmC@6c48a"],["node","_mesh","root","_parent","_spriteFrame","asset","_effectAsset","target","mainTexture","targetInfo","data","_textureSource","source","_skeleton","_font","_defaultClip","_normalSprite","_pressedSprite","_barSprite","value","playerCam","scene","rookieTip","levelManager","colliderManager","soccerAI","_envmap","_cameraComponent","graphics","Canvas","PlayAgainBtn","PlayAgainLay","RestartBtn"],[["cc.Node",["_name","_layer","_objFlags","__editorExtras__","_id","_parent","_components","_prefab","_lpos","_lrot","_euler","_lscale","_children"],-2,1,9,4,5,5,5,5,12],["cc.Node",["_name","_layer","_id","_objFlags","_children","_parent","_prefab","_lpos","_components","_lrot","_euler","_lscale"],-1,2,1,4,5,9,5,5,5],["cc.Widget",["_alignFlags","_alignMode","_isAbsTop","_originalWidth","_originalHeight","_top","_isAbsLeft","_isAbsRight","_isAbsBottom","_isAbsHorizontalCenter","_right","_left","_bottom","_isAbsVerticalCenter","_verticalCenter","node","__prefab"],-12,1,4],"cc.SpriteFrame","cc.ImageAsset",["cc.Sprite",["_sizeMode","_type","node","__prefab","_spriteFrame","_color"],1,1,4,6,5],["cc.MeshRenderer",["_shadowCastingMode","_name","_enabled","node","_materials","lightmapSettings","_mesh","__prefab"],0,1,3,4,6,4],["cc.BoxCollider",["_isTrigger","node","_center","_size","__prefab"],2,1,5,5,4],["cc.Material",["_defines","_states","_techIdx","_name","_props"],-1,12],["cc.Node",["_name","_layer","_id","_parent","_lpos","_lrot","_euler","_components","_prefab","_children","_lscale"],0,1,5,5,5,12,4,9,5],["cc.Animation",["node","_clips","__prefab","_defaultClip"],3,1,3,4,6],["cc.Node",["_name","_id","_parent","_components","_children","_prefab","_lpos"],1,1,2,2,4,5],["cc.Node",["_name","_layer","_children","_components","_prefab","_lpos","_parent","_lscale"],1,2,12,4,5,1,5],["cc.PrefabInfo",["fileId","root","asset","targetOverrides"],2,1,1,9],["cc.SkeletalAnimation",["playOnLoad","_useBakedAnimation","node","__prefab","_clips","_sockets","_defaultClip"],1,1,4,3,9,6],["cc.RigidBody",["_group","_type","_allowSleep","_linearDamping","_angularDamping","node","__prefab"],-2,1,4],["cc.SphereCollider",["_isTrigger","_radius","node","__prefab"],1,1,4],["cc.SkinnedMeshRenderer",["_shadowCastingMode","node","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton","__prefab"],2,1,3,4,1,6,6,4],["cc.UITransform",["node","__prefab","_contentSize","_anchorPoint"],3,1,4,5,5],["cc.TargetOverrideInfo",["propertyPath","targetInfo","target","source"],2,4,1,1],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides","mountedChildren","mountedComponents"],2,1,9,9,9],["cc.Prefab",["_name"],2],["cc.PrefabInfo",["fileId","root","instance","asset","targetOverrides"],2,1,4,6,9],["cc.ModelLightmapSettings",["_castShadow","_receiveShadow"],1],["cc.Mask",["_inverted","_enabled","node","__prefab"],1,1,4],["cc.Label",["_string","_actualFontSize","_fontSize","_lineHeight","_isSystemFontUsed","_overflow","_enableWrapText","node","__prefab","_font","_color"],-4,1,4,6,5],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],1,9],["cc.CurveRange",["constant"],2],["cc.Camera",["_visibility","_name","_fov","_projection","_priority","_orthoHeight","_far","_clearFlags","node","_color","__prefab"],-5,1,5,4],["cc.Button",["_transition","node","__prefab","_normalColor","_target","clickEvents"],2,1,4,5,1,9],"cc.TextureCube",["cc.CompPrefabInfo",["fileId"],2],["cc.SkeletalAnimation.Socket",["path","target"],2,1],["fd86ffDkKRKn6h9KvqsGwKC",["node","__prefab"],3,1,4],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.AudioClip",["_name","_native","_duration"],0],["cc.Layout",["node","__prefab"],3,1,4],["cc.ProgressBar",["_totalLength","_progress","node","__prefab","_barSprite"],1,1,4,1],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.LabelOutline",["_width","node","__prefab","_color"],2,1,4,5],["cc.LabelShadow",["node","__prefab","_offset"],3,1,4,5],["cc.SceneAsset",["_name"],2],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.TargetInfo",["localID"],2],["cc.SceneGlobals",["ambient","shadows","_skybox","fog"],3,4,4,4,4],["cc.AmbientInfo",["_skyIllum"],2],["cc.ShadowsInfo",["_enabled","_pcf","_normalBias","_shadowDistance","_invisibleOcclusionRange","_saturation","_shadowColor","_size"],-3,5,5],["cc.SkyboxInfo",["_enabled","_useIBL","_envmap"],1,6],["cc.FogInfo",[],3],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,1],["cc.ParticleSystem",["duration","simulationSpeed","enableCulling","_capacity","_simulationSpace","_materials","node","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","renderer"],-3,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4],["cc.GradientRange",["color"],3,5],["cc.ParticleSystemRenderer",["_renderMode"],2],["38d7a9AC1RJv6L3L4TXVNRA",[],3],["cc.MountedChildrenInfo",["nodes","targetInfo"],2,4],["ddb42chftVC96seHnHAsDUv",["ballNode","redTeam","blueTeam"],3,1,2,2],["7c1ab12XBZAS77ochDrKdLL",["node","playerCam","judgeRangePlane","judgeRangeSlide"],3,1,1,1,1],["cc.MountedComponentsInfo",["components","targetInfo"],2,4],["cc.DirectionalLight",["_colorTemperature","_illuminance","node","_staticSettings"],1,1,4],["cc.StaticLightSettings",[],3],["ad4a70DaVxHd7BlqgQPIZHs",["node","boundaryParent","goalNet","goalTargetPlaneCollider","goalPillerParent"],3,1,1,1,1,1],["d310cimFXVPuJ0rBtLZWMdT",["node"],3,1],["cc.TTFFont",["_name","_native"],1],["cc.Canvas",["node","__prefab","_cameraComponent"],3,1,4,1],["55efdsCpDVGzZjcOF2FF2qP",["node","__prefab","graphics"],3,1,4,1],["0295bsDktRCyoMFBCSxST3+",["node","__prefab"],3,1,4],["cc.Graphics",["_lineWidth","_lineJoin","_lineCap","_miterLimit","node","__prefab","_strokeColor"],-1,1,4,5],["cc.ClickEvent",["_componentId","handler","target"],1,1],["cc.AudioSource",["_playOnAwake","node","__prefab"],2,1,4],["7f9dfNADgJMQryVZRA23mUK",["node","__prefab","AudioList"],3,1,4,3]],[[13,0,1,2,2],[31,0,2],[44,0,2],[52,0,1,2,2],[23,1],[18,0,1,2,1],[1,0,5,4,6,7,9,10,2],[53,0,1,2,3],[22,0,1,2,3,2],[0,2,3,5,7,3],[0,0,5,6,7,8,9,10,2],[34,0,1,2,3],[6,3,7,4,5,6,1],[51,0,1,2,2],[5,2,3,4,1],[26,0,2,2],[9,0,3,9,8,4,5,6,2],[15,0,1,5,3],[6,1,2,3,4,5,6,3],[50,0,1,2,3],[8,3,1,0,4,4],[7,0,1,2],[0,0,5,6,8,9,11,10,2],[0,0,5,7,8,2],[35,0,1,2,4],[19,0,2,1,2],[0,0,1,5,6,7,8,9,10,3],[0,0,1,5,6,7,8,9,11,10,3],[21,0,2],[19,0,3,2,1,2],[0,0,5,7,8,9,11,10,2],[1,0,4,6,7,9,10,2],[27,1],[8,1,0,4,3],[0,0,5,8,9,11,10,2],[0,0,1,5,6,7,3],[5,0,2,3,5,4,2],[20,0,1,2,2],[0,0,5,6,8,11,2],[40,0,1,2,3,2],[41,0,1,2,1],[0,0,1,5,6,7,8,3],[36,0,1,1],[2,0,11,10,5,12,6,7,2,8,3,4,1,15,16,13],[25,0,1,2,3,4,7,8,10,9,6],[7,1,1],[8,2,1,0,4,4],[0,0,12,6,7,8,9,10,2],[0,0,5,7,2],[0,0,4,5,6,8,11,3],[1,0,1,4,8,6,3],[1,0,4,6,2],[1,0,4,2],[9,0,1,3,7,8,4,3],[17,0,1,7,2,3,4,5,6,2],[2,0,14,9,13,1,15,16,6],[5,1,0,2,3,4,3],[39,0,1,2,3,4],[6,1,3,4,5,6,2],[7,0,1,2,3,2],[27,0,2],[21,1],[0,0,5,6,7,9,10,2],[0,0,1,5,6,7,8,11,3],[0,0,5,6,7,2],[0,2,3,7,3],[1,0,1,5,4,8,6,3],[1,0,5,4,6,9,10,2],[11,0,1,2,3,3],[12,0,1,6,2,3,4,3],[14,0,1,2,3,4,3],[32,0,1,2],[15,0,1,5,6,3],[18,0,1,1],[18,0,1,2,3,1],[2,0,3,4,15,16,4],[24,0,2,3,2],[38,0,1,2,4],[6,0,3,4,5,6,2],[19,0,1,2],[26,0,1,2,3],[20,0,1,3,2,2],[20,0,1,4,2,2],[10,0,2,1,3,1],[10,0,2,1,1],[59,0,1,2],[62,0,1,2],[8,0,2],[0,0,12,7,8,9,10,2],[0,0,5,7,8,9,10,2],[0,0,1,6,7,8,11,3],[0,0,12,6,2],[0,0,2],[0,0,4,5,6,8,9,10,3],[0,0,5,6,9,10,2],[0,0,5,6,8,9,10,2],[0,0,2,1,5,6,7,8,11,4],[0,0,6,7,2],[1,0,3,5,4,8,6,7,3],[1,0,5,4,8,6,7,2],[1,0,1,5,4,8,6,7,11,3],[1,0,2,5,4,8,7,11,3],[1,0,4,8,7,9,10,2],[1,0,2,5,4,7,9,10,3],[1,0,5,4,2],[1,0,2,5,4,7,3],[9,0,3,7,4,5,10,6,2],[9,0,2,3,7,4,5,6,3],[11,0,1,2,4,3,3],[11,0,2,3,5,6,2],[12,0,1,2,3,4,5,3],[12,0,1,6,2,3,4,5,7,3],[13,3,1],[13,0,1,2,3,2],[22,0,1,2,4,3,2],[14,0,1,2,3,4,5,6,3],[14,2,1],[33,0,1,1],[15,0,2,3,4,5,5],[16,0,2,3,2],[16,2,3,1],[16,0,1,2,3],[17,1,7,2,3,4,5,6,1],[17,1,2,3,4,5,6,1],[23,0,1,3],[2,0,10,5,7,2,1,15,16,7],[2,0,6,7,2,8,3,4,1,15,16,9],[2,0,1,15,16,3],[2,0,6,3,4,1,15,16,6],[2,0,12,8,9,1,15,16,6],[2,0,5,2,9,13,1,15,16,7],[2,0,11,5,6,2,1,15,16,7],[2,0,3,4,1,15,16,5],[2,0,5,2,1,15,16,5],[24,1,0,2,3,3],[5,1,0,2,3,3],[5,0,2,3,4,2],[5,2,3,5,1],[37,0,1,2,3,4,3],[25,0,1,2,3,5,6,4,7,8,9,8],[6,0,3,7,4,5,6,2],[42,0,2],[7,1,2,3,1],[7,0,1,4,2,3,2],[43,0,1,2,3,2],[45,0,1,2,3,1],[46,0,2],[47,0,1,2,3,4,5,6,7,7],[48,0,1,2,3],[49,1],[54,0,1,2,2],[10,0,1,1],[10,0,2,1],[55,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,7],[56,0,1],[57,0,2],[58,1],[60,0,1,2,1],[61,0,1,2,3,1],[63,0,1,2,3,3],[64,1],[65,0,1,2,3,4,1],[66,0,1],[28,1,2,0,8,9,4],[28,3,4,5,6,7,0,8,10,9,7],[67,0,1,3],[68,0,1,2,1],[69,0,1,2,1],[70,0,1,1],[71,0,1,2,3,4,5,6,5],[29,0,1,2,3,4,2],[29,0,1,2,5,3,4,2],[72,0,1,2,3],[73,0,1,2,2],[74,0,1,2,1]],[[[{"fmt":"0","w":0,"h":0},-1],[4],0,[],[],[]],[[[46,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"mainColor",8,[4,2214592511],"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[46,15]],[[[28,"goalKeeper"],[47,"goalKeeper",[[-6,-7,-8,-9,-10,[48,"Dummy_ball",-12,[0,"49fYFKNNROS7leLgTPOtRZ",-11,0]]],1,1,1,1,1,4],[[115,true,false,-4,[1,"57FGriRHBaGLpGiH9fJYnh"],[6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[[71,"Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand",-2],[71,"Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand",-3]],21],[117,-5,[1,"6bR8fWh5ZDApbCnaDhxFqy"]]],[0,"ff35WAxT1Ul7D6wG+gDQYZ",-1,0],[1,0,0,28],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[88,"Bip01 Spine",[[-13,-14,-15,[89,"RootNode",-16,[0,"d8tG3v0cRD25fRM+hR3sYJ",1,0],[1,-0.7640838776881971,0.17617299874864045,0.0008139568261347208],[3,-0.5686774769259988,-0.452028864830105,-0.5372292109147399,0.4285564228166611],[1,-102.9641711847085,-89.19040024707846,3.0754645894294836]]],1,1,1,4],[0,"78+5TeXDxbN66ertwa0f5Q",1,0],[1,0.0055677033960819244,-0.0003765177680179477,-0.000009474754733673763],[3,0.006185202759122735,0.048699109957307876,0.12600217555446833,0.9908146101626356],[1,-0.0009237367740082856,5.627829881829226,14.494793129923595]],[31,"Bip01 Pelvis",[2,-17,-18],[0,"78Kk+weHFfdIMu8+FZwRiY",1,0],[1,-2.38418573772492e-9,-0.0011781358625739813,-7.629394360719743e-8],[3,-0.5000006631012023,-0.49999932199667485,-0.499999292194352,0.5000007227058479],[1,-89.99999487735566,-89.99984119809935,-0.0000017075402189495764]],[10,"Bip01 L Hand Socket",1,[[72,32,4,-19,[1,"775cTMQnxIsItUNxODumJB"]],[119,true,-20,[1,"afzymnu5dPyYIERB0WDIo/"]]],[0,"4abdWlKXFGgZulzLMG3N1D",1,0],[1,0.1704716358874589,1.0025965328428363,0.24979258963111511],[3,0.35750103737481187,-0.24881077334149324,0.7144441992870899,0.5475908088443155],[1,110.30892572422596,-100.4642467407012,37.196174760161185]],[10,"Bip01 R Hand Socket",1,[[72,32,4,-21,[1,"775cTMQnxIsItUNxODumJB"]],[120,-22,[1,"8e74bw6wZOIaUpJ+We2SsW"]]],[0,"b56BG2F+9N7qKK7KVECKY7",1,0],[1,-0.24089158329282143,0.9640380067815274,0.044496402513010735],[3,0.43232201570465795,0.33125116731003057,0.7602687181449208,-0.35406472959613444],[1,-123.19457517828248,-112.8293994845934,-14.593189643541502]],[31,"Bip01 L Hand",[-23,-24],[0,"d4KvSmIt5cT4ZApoebztzu",1,0],[1,0.25255653262138367,-7.629394360719743e-8,0],[3,-0.6554790196693331,-0.030115377422082146,-0.3441724807410603,0.6715546309248415],[1,-96.09459577485248,-32.854980070702496,-25.010304396689936]],[31,"Bip01 R Hand",[-25,-26],[0,"a9Zk+FGNlbuKY70ycsirCi",1,0],[1,0.25255662202835083,3.814697180359872e-8,7.105427198782324e-17],[3,0.7033935667527508,0.1284220197157317,-0.26590436251814326,0.6465602408877272],[1,97.6264653247762,33.19392588432115,-9.391751626957756]],[6,"Bip01",1,[3],[0,"23SOiLJlhTaa3n5VQuHara",1,0],[1,0.0011706282384693623,0.7784847021102905,-0.00006189870327943936],[3,0.5448971270555572,0.4682852522573813,0.5029548295682065,-0.48045029176685594],[1,-95.72704220546849,-86.81781659959945,1.5497526298870348]],[6,"Bip01 Neck",2,[-27],[0,"19tEG1Hn9eWY8yO2AcTwxD",1,0],[1,0.4921576678752899,0.004864463582634926,-0.000002571195409473148],[3,0.04290756262952485,0.02058394092063683,0.0252704511680931,0.9985472681566607],[1,4.862560102540894,2.2346847452485847,2.994144221877177]],[16,"Bip01 Head",9,[[23,"Bip01 HeadNub",-28,[0,"25mSQgTL1ZjYSXq6cJVTLf",1,0],[1,0.4308357238769531,9.53674295089968e-9,3.552713599391162e-17]]],[0,"12bHt6QrhaSpUNWGc3Xldk",1,0],[1,0.039125822484493256,1.907348590179936e-8,1.776356799695581e-17],[3,-0.13447596060568745,-0.05548953235164991,-0.14743204335703167,0.9783153481419695],[1,-16.891730533959947,-8.864735321331683,-15.87538668364434]],[6,"Bip01 L Clavicle",2,[-29],[0,"48S157hklcmZ5kzs8xIUQs",1,0],[1,0.4516083598136902,-0.012276649475097656,0.029130801558494568],[3,0.614231007885865,0.1059905916806379,0.7774257285057733,0.08423479141049901],[1,-176.35781561858622,-103.86084828649889,15.139972216061024]],[6,"Bip01 L UpperArm",11,[-30],[0,"deYvatZuRaLrv68TukiBWf",1,0],[1,0.11830057203769684,-1.907348590179936e-8,0],[3,0.11808933398198838,0.36335838088846284,0.08353396562088025,0.9203519287889035],[1,9.28591958400456,41.95735168128716,13.861681617323258]],[6,"Bip01 L Forearm",12,[6],[0,"f8hTG4LZRbRphmpwRXdLLB",1,0],[1,0.25530532002449036,0,0],[3,-1.4237388936237812e-18,-5.592502475196377e-17,0.8805885104623536,-0.47388171017849295],[1,180,180,-56.57312647111236]],[16,"Bip01 L Finger0",6,[[23,"Bip01 L Finger0Nub",-31,[0,"60TOZmlyNfbYBBv1HWNYu7",1,0],[1,0.10331199318170547,-3.814697180359872e-8,-1.4210854397564648e-16]]],[0,"58QZfQoZ1awqL+GHiYbr1q",1,0],[1,0.07214080542325974,-7.105427198782324e-17,-3.814697180359872e-8],[3,-0.00039812179547901727,1.4904125640608516e-8,-7.444647418823864e-9,0.9999999207495147],[1,-0.0456213984313964,0.0000017075472225111888,-8.537736335512049e-7]],[16,"Bip01 L Finger1",6,[[23,"Bip01 L Finger1Nub",-32,[0,"c8CPb7A+tXlL6fNdNRgkJI",1,0],[1,0.10687568783760071,-3.814697180359872e-8,-7.629394360719743e-8]]],[0,"a7dR9SkIZYBajY66udFPK8",1,0],[1,0.07167846709489822,0.0006313705234788358,0.021634826436638832],[3,-0.0003981441472168258,1.4904125640475882e-8,-7.444646974668412e-9,0.9999999207406156],[1,-0.04562395975208181,0.0000017075472034329276,-8.537736208213878e-7]],[6,"Bip01 R Clavicle",2,[-33],[0,"c1BytVJrpW9IlMhkwyHjh6",1,0],[1,0.45160841941833496,-0.01227649673819542,-0.02913086861371994],[3,-0.6838445644693675,0.11528795180882723,0.7119839171906407,-0.11020073264410532],[1,-179.18836425087892,92.44080615224583,-18.336690610480556]],[6,"Bip01 R UpperArm",16,[-34],[0,"eckBF0AhJbKKttt28luY8z",1,0],[1,0.11830057203769684,3.814697180359872e-8,-1.4210854397564648e-16],[3,-0.3631718509524952,-0.4031382261690234,0.15984136098462784,0.8246432662646398],[1,-34.456376758617324,-41.337078790439286,33.81003271413883]],[6,"Bip01 R Forearm",17,[7],[0,"9bFaYqyChfY59Alb4jBscY",1,0],[1,0.2553054094314575,-7.629394360719743e-8,7.105427198782324e-17],[3,-3.616810840714558e-18,-1.9290012401901035e-17,-0.8253053445621281,0.5646867168945866],[1,-180,-180,-68.76107840101615]],[16,"Bip01 R Finger0",7,[[30,"Bip01 R Finger0Nub",-35,[0,"e3rvwV0y1Sm6hugWhYmEHq",1,0],[1,0.10331201553344727,0,1.4210854397564648e-16],[3,7.450580596923828e-9,4.562165038977444e-25,1,-6.123234262925839e-17],[1,-1,-1,-1],[1,-180,-179.99999914622634,-7.0167096047110005e-15]]],[0,"fdjhHGBLVRHqqHKfsq5KHF",1,0],[1,0.0721408873796463,1.4210854397564648e-16,1.4210854397564648e-16],[3,0.00039812921695446166,-7.453546078213996e-9,-7.447613490576177e-9,0.9999999207465602],[1,0.04562224886991161,-8.537736208172892e-7,-8.537736207970288e-7]],[16,"Bip01 R Finger1",7,[[30,"Bip01 R Finger1Nub",-36,[0,"baiqamLjBQz5RKMZCgQBsm",1,0],[1,0.10687566548585892,7.629394360719743e-8,-7.629394360719743e-8],[3,-7.450580596923828e-9,-3.469447282825859e-17,1,-7.450580596923828e-9],[1,-1,-1.0000001192092896,-1],[1,180,179.99999914622634,-8.537736462515939e-7]]],[0,"d8C7mOY3lXm5UHPXUIChkl",1,0],[1,0.07167850434780121,0.0006314087077043951,-0.021634826436638832],[3,0.00039815901927153937,-7.453546078125555e-9,-7.447613490487807e-9,0.9999999207346946],[1,0.045625663964158805,-8.537735953627242e-7,-8.537736462313321e-7]],[6,"Bip01 L Thigh",3,[-37],[0,"06//swxr5du4krd2hgb5l5",1,0],[1,-1.5258788721439487e-7,2.0742416495522775e-7,0.1258874386548996],[3,-0.1348426063413046,0.9834635995447685,0.07523845989614135,-0.09463611381490548],[1,-7.327965175591944,-170.05317385124434,-16.228344923236463]],[6,"Bip01 L Calf",21,[-38],[0,"141Joly0peo7qYaqpozJAT",1,0],[1,0.3375164270401001,-1.907348590179936e-8,0],[3,1.9779241633007607e-17,-6.4896785565582584e-18,-0.31175371877442515,0.9501629433051557],[1,2.385416263074054e-15,7.855124317273805e-24,-36.329899104889755]],[6,"Bip01 L Foot",22,[-39],[0,"12F9BLnbFahomhselvozdM",1,0],[1,0.2580810487270355,3.814697180359872e-8,-3.552713599391162e-17],[3,0.028680729125050125,-0.044580221761534596,0.08601258063011458,0.9948828351006443],[1,3.7657200527503165,-5.451189556921288,9.705714728893218]],[16,"Bip01 L Toe0",23,[[30,"Bip01 L Toe0Nub",-40,[0,"feDJEeu6tU84jN2td5CXas",1,0],[1,0.13195955753326416,2.38418573772492e-9,-1.907348590179936e-8],[3,5.3551048040390015e-9,1.862645149230957e-9,1,7.450580596923828e-9],[1,-1,-1,-1],[1,-179.9999997865566,-179.9999993863502,8.537736473946058e-7]]],[0,"e6KoGOnZhc6IllXqapHTlV",1,0],[1,0.1066858321428299,0.18787610530853271,0],[3,-0.010015184113674172,-0.011061658211018439,0.8493673847163346,0.5275911121170694],[1,178.93671737938615,179.3093883490468,63.696444692646544]],[6,"Bip01 R Thigh",3,[-41],[0,"63YoYbwihfVq+C1uJb1ubA",1,0],[1,2.288818308215923e-7,-1.406669554171458e-7,-0.1258874237537384],[3,0.1940873079822511,0.9764843995856716,-0.07963301091918047,-0.049668076447141364],[1,8.49661779274763,-175.88996697436087,22.76528046580491]],[6,"Bip01 R Calf",25,[-42],[0,"d7AoqkFvBRSYr1NLXpzFqG",1,0],[1,0.3375163972377777,0,1.776356799695581e-17],[3,4.303235122230545e-18,6.033345841197668e-18,-0.8295652345482472,0.5584098151258727],[1,180,180,-67.8917940965223]],[6,"Bip01 R Foot",26,[-43],[0,"243XxYtCxegK+dy/qNdun+",1,0],[1,0.25808098912239075,7.105427198782324e-17,-9.53674295089968e-9],[3,0.048719372105094326,0.1057958294128115,0.12837627399606044,0.9848620195415342],[1,4.089481092363769,11.714621432387062,15.258506239142363]],[16,"Bip01 R Toe0",27,[[23,"Bip01 R Toe0Nub",-44,[0,"c7Q00V9XJQ35bdhmC54uG4",1,0],[1,0.13195957243442535,4.76837147544984e-9,-9.53674295089968e-9]]],[0,"5cLoA5EsFavIlrolfDjTNK",1,0],[1,0.10668587684631348,0.1878761500120163,1.776356799695581e-17],[3,-0.00019861398289968836,-0.00019443783061864564,0.7251815783847774,0.6885576236726878],[1,179.99060378085323,179.97753714721676,87.03208521643715]],[10,"player_uniform_lod0",1,[[54,1,-45,[1,"f5E/zK38hWx7N0DvHJ2ykh"],[0],[4],1,1,2]],[0,"c5E76aQ+1bt5PAvFsp8p+o",1,0],[1,2.551235889214354e-9,2.551235889214354e-9,-0.05836546793580055],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[62,"mesh_glove",1,[[122,-46,[1,"d0rijYX/RW6rWJq2ho+xQa"],[3],[4],1,4,5]],[0,"feAKxoSvdWw4bgvB2bJ0SO",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,2,1,0,7,4,0,7,5,0,0,1,0,0,1,0,-1,8,0,-2,29,0,-3,30,0,-4,4,0,-5,5,0,2,1,0,3,1,0,-1,9,0,-2,11,0,-3,16,0,3,2,0,-2,21,0,-3,25,0,0,4,0,0,4,0,0,5,0,0,5,0,-1,14,0,-2,15,0,-1,19,0,-2,20,0,-1,10,0,3,10,0,-1,12,0,-1,13,0,3,14,0,3,15,0,-1,17,0,-1,18,0,3,19,0,3,20,0,-1,22,0,-1,23,0,-1,24,0,3,24,0,-1,26,0,-1,27,0,-1,28,0,3,28,0,0,29,0,0,30,0,10,1,2,3,3,3,3,8,6,3,13,7,3,18,46],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,1,13,-1,1,13,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,15],[27,16,17,47,48,49,18,10,19,20,50,51,52,53,54,55,56,57,58,59,21,10]],[[[11,".bin",2714577712,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":1200,"count":600,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[[11,".bin",4094896171,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":72,"count":36,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":24,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,-0.5],"maxPosition",8,[1,0.5,0.5,0.5]]],-1],0,0,[],[],[]],[[[24,"ButtonClick",".mp3",0.156735],-1],0,0,[],[],[]],[[{"base":"2,2,0,0,0,0","rgbe":false,"mipmaps":[{"front":"76vT+ezDBPjbQDqqR0tllX","back":"4fl1qYOUlP3q2zPTqQSxkl","left":"8fjEl1EgRNpbSwiLRc18Uf","right":"89poShR5JPO4BugQwvdCY8","top":"ee6HQQQ8xEnLxR9SD4P+HK","bottom":"08i7r04EVKhJCABsPefAF6"}]}],[30],0,[],[],[]],[[[28,"background_Layout"],[50,"background_Layout",33554432,[-4,-5,-6,-7,-8,-9,-10,-11],[[5,-2,[1,"600mRYvYBPMbdzjbuoATeB"],[5,1280,2400]],[42,-3,[1,"0bKE5MLrRAyJj89BkMTxFB"]]],[0,"a2dB6QwRBP8pLu2mgFdr8K",-1,0]],[98,"bg",512,1,[-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23],[[73,-12,[1,"33cSrnIglBi7H6ZvQHRp0T"]]],[0,"42fsjZWD1Ea5sUZIVL6GsJ",1,0],[1,127.901,32.173,0]],[99,"grass",1,[-25,-26,-27,-28,-29,-30,-31,-32,-33,-34],[[73,-24,[1,"af8eBn14JM7aT74opyRi9M"]]],[0,"01dlUWiOZBBrYubghgVdHw",1,0],[1,159.642,54.072,0]],[66,"BGMaskblack",33554432,1,[-38],[[5,-35,[1,"71g4qUBtdHX6TAdT5f1gT8"],[5,1280,2400]],[75,45,100,100,-36,[1,"44Av/T2YRNpbFGN2gy2/p5"]],[134,false,true,-37,[1,"8bb/7EV/hIBaNdA6sM6sG0"]]],[0,"e7TEiF9VNM46wSvyBZacGM",1,0]],[100,"ProgressBar",33554432,1,[-43],[[5,-39,[1,"edjSkVkHVHNL59TWVu6cTU"],[5,300,15]],[56,1,0,-40,[1,"2cH/MIWFdIB5rCqcY9kuDx"],25],[138,300,1,-42,[1,"55hxuuz8hEIbMBQc78zk4O"],-41]],[0,"41mRT+nrdEdLnrOlXpoNnN",1,0],[1,56.924,-605.467,0],[1,1.5,2.5,1]],[66,"BGMask",33554432,1,[-47],[[5,-44,[1,"acUC4hoVBDpIRgUJCoJq4O"],[5,1280,2400]],[75,45,100,100,-45,[1,"84TpvgoHJNOJVMMIMWnjdB"]],[76,true,-46,[1,"8cvjs8eNtLR4oqb9QG1tFT"]]],[0,"4a0gysKblHHq7Zx8XvlFqJ",1,0]],[35,"SpriteSplash",33554432,4,[[5,-48,[1,"c3kMtEG1ZPtqY1n8ZD9Hrd"],[5,6000,6000]],[36,0,-49,[1,"4bgUTLhVdI3JyPBtIM5B0e"],[4,4293181109],0]],[0,"43ui8sQEZMmJGn7MDaepmF",1,0]],[26,"grass1",33554432,3,[[5,-50,[1,"0d0gNH6LVA4LYR2LWXLTy8"],[5,177,1254]],[14,-51,[1,"8cHfAfGqRAuY47QIfvfntJ"],1]],[0,"6cARv9GCxDwJC9+sJtQlh5",1,0],[1,704.115,-781.717,0],[3,0,0,0.14504698508823366,0.989424768295606],[1,0,0,16.68]],[27,"grass2",33554432,3,[[5,-52,[1,"dcfpCJR8BJ2qVosgmeCcWL"],[5,177,1254]],[14,-53,[1,"12U/oguvFJ8phPEeQQaG5f"],2]],[0,"37s7hpR2pDoYTsCygT/1FB",1,0],[1,534.8040000000001,-832.449,0],[3,0,0,0.14504698508823366,0.989424768295606],[1,-1,1,1],[1,0,0,16.68]],[26,"grass3",33554432,3,[[5,-54,[1,"a59+DELlxN6YjMDghaBfN0"],[5,177,1254]],[14,-55,[1,"040FYbwbNP3LzmXsaMrpb6"],3]],[0,"faeWqiMWFDVbXekMhNymnq",1,0],[1,367.02199999999993,-882.722,0],[3,0,0,0.14504698508823366,0.989424768295606],[1,0,0,16.68]],[27,"grass4",33554432,3,[[5,-56,[1,"b9Vkym/6lDLqsDOqKs2kaZ"],[5,177,1254]],[14,-57,[1,"07xNir8g9NUIqVvjiAXJD+"],4]],[0,"ebjznUWr1MyLOZQ1gfM5IO",1,0],[1,197.98800000000006,-933.37,0],[3,0,0,0.14504698508823366,0.989424768295606],[1,-1,1,1],[1,0,0,16.68]],[26,"grass5",33554432,3,[[5,-58,[1,"f3ZbJCb4lFyoM8xUfy0Lhp"],[5,177,1254]],[14,-59,[1,"52tGwfzTVFVKdB90Nmor5P"],5]],[0,"27Q74feQ1CSpI40QDMFX6i",1,0],[1,30.147000000000048,-983.661,0],[3,0,0,0.14504698508823366,0.989424768295606],[1,0,0,16.68]],[27,"grass6",33554432,3,[[5,-60,[1,"11SqAgbn5I+pJ9YOYksyBw"],[5,177,1254]],[14,-61,[1,"95po+JqM9HzLyG4gr4mXco"],6]],[0,"f1rDltn2VGFZCzDh3+p95a",1,0],[1,-137.99099999999999,-1034.041,0],[3,0,0,0.14504698508823366,0.989424768295606],[1,-1,1,1],[1,0,0,16.68]],[26,"grass7",33554432,3,[[5,-62,[1,"27M5PCYrZITbZk+fwU3O6D"],[5,177,1254]],[14,-63,[1,"11VCOzMQxOyobhp8a89zWX"],7]],[0,"06foC/nu1MiIjfiMTuh/Dm",1,0],[1,-307.31,-1084.775,0],[3,0,0,0.14504698508823366,0.989424768295606],[1,0,0,16.68]],[27,"grass8",33554432,3,[[5,-64,[1,"15Lsjy8ZJLG5XHu0Lrs5Rk"],[5,177,1254]],[14,-65,[1,"73Us9RFjhJtpiF22efeVgq"],8]],[0,"22ntDKBZZLxYfzIY5qN9F2",1,0],[1,-476.574,-1135.492,0],[3,0,0,0.14504698508823366,0.989424768295606],[1,-1,1,1],[1,0,0,16.68]],[26,"grass9",33554432,3,[[5,-66,[1,"c6phQtD/VPzKuj8PG8oCFt"],[5,177,1254]],[14,-67,[1,"4bnqBEeSFInp1bk6Be2RjT"],9]],[0,"b01kf7AyVOwLHsh7aIHach",1,0],[1,-646.067,-1185.982,0],[3,0,0,0.14504698508823366,0.989424768295606],[1,0,0,16.68]],[27,"grass10",33554432,3,[[5,-68,[1,"cb9ubtBUFBAr3auadCJylY"],[5,177,1254]],[14,-69,[1,"ceOdpHtH9L0Yo0In5iTWDd"],10]],[0,"84Y9Z7Pw5JQrLfHc6Y7RLk",1,0],[1,-814.834,-1237.052,0],[3,0,0,0.14504698508823366,0.989424768295606],[1,-1,1,1],[1,0,0,16.68]],[27,"grassMask",33554432,1,[[5,-70,[1,"c7mZoypxxCqbh6bmsBo0ug"],[5,4,684]],[14,-71,[1,"f8hYERr4hF2rWKcAedPXhO"],11]],[0,"e7hHdQLXNK9Lq/VzRJQHr6",1,0],[1,130.52,-841.381,0],[3,0,0,0.14504698508823363,0.9894247682956061],[1,500,1.6,1],[1,0,0,16.68]],[26,"bg1",33554432,2,[[5,-72,[1,"536z4TO8NLAa0gUc7I9xaF"],[5,180,1593]],[14,-73,[1,"f6y4TZwhRCxL2VLI61EzyA"],12]],[0,"deLMxFN4xEPJs7tLNuscWn",1,0],[1,588.592,670.599,0],[3,0,0,0.14504698508823363,0.9894247682956061],[1,0,0,16.68]],[27,"bg2",33554432,2,[[5,-74,[1,"150BJBpclN3bhjpegmGxCA"],[5,180,1593]],[14,-75,[1,"d09jqv5BBBIJPi8z8CpoyF"],13]],[0,"5b69VrjtRCh4pe3ZOuZtzx",1,0],[1,417.162,619.233,0],[3,0,0,0.14504698508823363,0.9894247682956061],[1,-1,1,1],[1,0,0,16.68]],[26,"bg3",33554432,2,[[5,-76,[1,"c0xlPPQnhBN77vSOAbonSK"],[5,180,1593]],[14,-77,[1,"94XOfDo1VOT718OyYX82s2"],14]],[0,"6cIySB+FxEXp+rh/E5wN0t",1,0],[1,245.259,567.725,0],[3,0,0,0.14504698508823363,0.9894247682956061],[1,0,0,16.68]],[27,"bg4",33554432,2,[[5,-78,[1,"5ePJXYNyhMFJz7qxWv2lbv"],[5,180,1593]],[14,-79,[1,"e5un05shVM8pfcyCIc0eeA"],15]],[0,"27yYR2YE9AzrH4vcwij57P",1,0],[1,73,516.11,0],[3,0,0,0.14504698508823363,0.9894247682956061],[1,-1,1,1],[1,0,0,16.68]],[26,"bg5",33554432,2,[[5,-80,[1,"deLusWxQxFH4MeFvFIXQ9t"],[5,180,1593]],[14,-81,[1,"71Dqjes0lKBZKNdFrZ+Aq5"],16]],[0,"04ToGHOtNPzYeXmsGvGn49",1,0],[1,-99.364,464.464,0],[3,0,0,0.14504698508823363,0.9894247682956061],[1,0,0,16.68]],[27,"bg6",33554432,2,[[5,-82,[1,"a7r4YTaGtNG4Yy+mGllIqk"],[5,180,1593]],[14,-83,[1,"133bpligZOWob9ZZTAhlhH"],17]],[0,"c8gZND7v9NTJwBKoE8uIeI",1,0],[1,-270.894,413.068,0],[3,0,0,0.14504698508823363,0.9894247682956061],[1,-1,1,1],[1,0,0,16.68]],[26,"bg7",33554432,2,[[5,-84,[1,"9cCnjuZaJAcLbc9vFfRTI3"],[5,180,1593]],[14,-85,[1,"6fY72GW4ZNlKpdd1GKRC5Z"],18]],[0,"d6gcE+OYlOMrE/X5INa9e2",1,0],[1,-442.587,361.623,0],[3,0,0,0.14504698508823363,0.9894247682956061],[1,0,0,16.68]],[27,"bg8",33554432,2,[[5,-86,[1,"5dE/l1AfNKEoUcRPNdoS3n"],[5,180,1593]],[14,-87,[1,"eeFZQm2aRBYZNqatfsnQ6q"],19]],[0,"07j1y2HRRGJpaN/6Dc7qGr",1,0],[1,-614.622,310.075,0],[3,0,0,0.14504698508823363,0.9894247682956061],[1,-1,1,1],[1,0,0,16.68]],[26,"bg9",33554432,2,[[5,-88,[1,"ffWV9iuF5N76ezba1ges2p"],[5,180,1593]],[14,-89,[1,"4bM8XmjvZJgr5TF7yTvjp6"],20]],[0,"73+2PENCFNrq9KF5JdisJR",1,0],[1,-785.783,258.789,0],[3,0,0,0.14504698508823363,0.9894247682956061],[1,0,0,16.68]],[27,"bg10",33554432,2,[[5,-90,[1,"78zGmVZ9BN4YzuKZlSL1Z4"],[5,180,1593]],[14,-91,[1,"c0TK7QBv9KZ6hl/0FGPUfL"],21]],[0,"c6pjpWRhlJE7qXgv8L56Q8",1,0],[1,-958.001,207.887,0],[3,0,0,0.14504698508823363,0.9894247682956061],[1,-1,1,1],[1,0,0,16.68]],[26,"bg11",33554432,2,[[5,-92,[1,"22/RfB9xdFpZ5tTJKH32Yq"],[5,180,1593]],[14,-93,[1,"f3IF1R1htA/L20V5m1wJF2"],22]],[0,"89uD1KoCNGnY95SULpp0U3",1,0],[1,-1129.772,155.816,0],[3,0,0,0.14504698508823363,0.9894247682956061],[1,0,0,16.68]],[63,"BG_player",33554432,1,[[5,-94,[1,"33wzoW7CJJQITq4+UrMo4M"],[5,1669,1245]],[14,-95,[1,"89n3qguaJNqoCBSx601fXY"],23]],[0,"2cTKbV4OlIuowjoaanX86o",1,0],[1,-8.542,-403.445,0],[1,0.6,0.6,0.6]],[63,"LOGO",33554432,1,[[5,-96,[1,"92oCMzS/5N7aqBuYmTn56Q"],[5,627,511]],[14,-97,[1,"4euE31WMFNoZKEoyIyH6IX"],24]],[0,"6boRRlkapHF5uF81G+qHxA",1,0],[1,0,265.786,0],[1,0.8,0.8,1]],[53,"Bar",33554432,5,[[[74,-98,[1,"94aE9Bz6VOo5l/XdCpHOZC"],[5,300,15],[0,0,0.5]],-99],4,1],[0,"65DYONQD5NZbkZe5In+b7r",1,0],[1,-150,0,0]],[35,"SpriteSplash",33554432,6,[[5,-100,[1,"31VJF116JIk7DCrOgEtYnK"],[5,6000,6000]],[36,0,-101,[1,"8esNIeqn5N4IdOcvbTxWcO"],[4,4278190080],26]],[0,"13NyX1bHZKN6Jyq203AuiB",1,0]],[135,1,0,32,[1,"adGtOAJU9KP6HwVxEvFTSH"]]],0,[0,2,1,0,0,1,0,0,1,0,-1,4,0,-2,3,0,-3,18,0,-4,2,0,-5,30,0,-6,31,0,-7,5,0,-8,6,0,0,2,0,-1,19,0,-2,20,0,-3,21,0,-4,22,0,-5,23,0,-6,24,0,-7,25,0,-8,26,0,-9,27,0,-10,28,0,-11,29,0,0,3,0,-1,8,0,-2,9,0,-3,10,0,-4,11,0,-5,12,0,-6,13,0,-7,14,0,-8,15,0,-9,16,0,-10,17,0,0,4,0,0,4,0,0,4,0,-1,7,0,0,5,0,0,5,0,18,34,0,0,5,0,-1,32,0,0,6,0,0,6,0,0,6,0,-1,33,0,0,7,0,0,7,0,0,8,0,0,8,0,0,9,0,0,9,0,0,10,0,0,10,0,0,11,0,0,11,0,0,12,0,0,12,0,0,13,0,0,13,0,0,14,0,0,14,0,0,15,0,0,15,0,0,16,0,0,16,0,0,17,0,0,17,0,0,18,0,0,18,0,0,19,0,0,19,0,0,20,0,0,20,0,0,21,0,0,21,0,0,22,0,0,22,0,0,23,0,0,23,0,0,24,0,0,24,0,0,25,0,0,25,0,0,26,0,0,26,0,0,27,0,0,27,0,0,28,0,0,28,0,0,29,0,0,29,0,0,30,0,0,30,0,0,31,0,0,31,0,0,32,0,-2,34,0,0,33,0,0,33,0,10,1,101],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34],[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],[8,4,4,4,4,4,4,4,4,4,4,60,3,3,3,3,3,3,3,3,3,3,3,61,22,62,8,63]],[[[77,"builtin-standard",[{"hash":3247695832,"name":"builtin-standard|standard-vs|standard-fs","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nlayout(location = 0) out float v_fog_factor;\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 13) in vec4 a_color;\n  layout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if USE_NORMAL_MAP\n  layout(location = 7) out vec3 v_tangent;\n  layout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(location = 0) in float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 9) uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 6) in vec2 v_uv1;\nlayout(location = 4) in vec3 v_normal;\n#if USE_VERTEX_COLOR\n  layout(location = 2) in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 7) in vec3 v_tangent;\n  layout(location = 8) in vec3 v_bitangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * miscParams.x) * normalize(v_tangent) +\n      (nmmp.y * miscParams.x) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.w;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  layout(location = 3) out vec4 fragColor3;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(s.position, s.roughness);\n    fragColor2 = vec4(s.normal, s.metallic);\n    fragColor3 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nout float v_fog_factor;\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nin float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * miscParams.x) * normalize(v_tangent) +\n      (nmmp.y * miscParams.x) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.w;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  layout(location = 3) out vec4 fragColor3;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(s.position, s.roughness);\n    fragColor2 = vec4(s.normal, s.metallic);\n    fragColor3 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n#endif\n      uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 miscParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nvarying float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowWHPBInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * miscParams.x) * normalize(v_tangent) +\n      (nmmp.y * miscParams.x) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.w;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(s.position, s.roughness);\n    gl_FragData[2] = vec4(s.normal, s.metallic);\n    gl_FragData[3] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]}]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":220,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":63}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":13,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","type":14,"count":1,"stageFlags":1,"format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":1,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":1,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":1,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":1,"location":6,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":1,"location":7,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":1,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":1,"location":9,"defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}]},{"hash":1783225275,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 13) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\n      uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":183,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":63}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_texCoord1","type":14,"count":1,"stageFlags":1,"format":21,"location":13,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":1,"location":1,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":1,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":1,"location":3,"defines":[]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["miscParams",0,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"miscParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0,0,0]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}},"migrations":{"properties":{"pbrParams":{"removeImmediately":true}}}},{"phase":"deferred","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","blendState":{"targets":[{"blend":false},{"blend":false},{"blend":false},{"blend":false}]},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["miscParams",0,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"miscParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0,0,0]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["miscParams",0,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"miscParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0,0,0]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["miscParams",0,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"miscParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0,0,0]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["miscParams",0,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"miscParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0,0,0]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[[24,"sfx_move_2",".mp3",0.18],-1],0,0,[],[],[]],[[[11,".bin",1218039912,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":20448,"length":3360,"count":840,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":20448,"count":284,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1]]},"minPosition",8,[1,-0.8909889459609985,-0.08271618187427521,1.0685659646987915],"maxPosition",8,[1,0.8909889459609985,0.14948277175426483,1.1999146938323975]]],-1],0,0,[],[],[]],[[[11,".bin",3984318300,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":39168,"length":8880,"count":2220,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":39168,"count":544,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]]},"minPosition",8,[1,-0.8229596018791199,-0.29883766174316406,-0.004503002390265465],"maxPosition",8,[1,0.8198345899581909,0.2980174124240875,1.7986453771591187]]],-1],0,0,[],[],[]],[[[20,"glove",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[64,0]],[[[57,"Skin-0",4038358698,["Bip01/Bip01 Pelvis/Bip01 L Thigh/Bip01 L Calf/Bip01 L Foot","Bip01/Bip01 Pelvis/Bip01 L Thigh/Bip01 L Calf","Bip01/Bip01 Pelvis/Bip01 L Thigh","Bip01/Bip01 Pelvis","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 Neck/Bip01 Head","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 R Clavicle","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 L Clavicle","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 Neck","Bip01/Bip01 Pelvis/Bip01 Spine","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 L Clavicle/Bip01 L UpperArm","Bip01/Bip01 Pelvis/Bip01 R Thigh","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand","Bip01/Bip01 Pelvis/Bip01 R Thigh/Bip01 R Calf/Bip01 R Foot","Bip01/Bip01 Pelvis/Bip01 R Thigh/Bip01 R Calf","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 R Clavicle/Bip01 R UpperArm","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger0","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger1","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger0","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger1"],[[[7,-0.0000018781279322865885,-0.009410581551492214,-0.9999557137489319,0,-0.000014098522115091328,-0.9999557137489319,0.009410581551492214,0,-1,0.000014115571502770763,0.000001745369445416145,0,0.10318773239850998,0.039511989802122116,0.13095007836818695,1],[7,0.00983881950378418,-0.01100983377546072,-0.9998909831047058,0,0.10632085800170898,-0.9942595362663269,0.01199401170015335,0,-0.9942831993103027,-0.10642727464437485,-0.008611764758825302,0,0.3553161919116974,0.05048731341958046,0.13173148036003113,1],[7,0.008561553433537483,-0.012029924429953098,-0.9998909831047058,0,-0.004231678321957588,-0.999919056892395,0.011994030326604843,0,-0.9999544620513916,0.004128528758883476,-0.008611767552793026,0,0.6962359547615051,0.010902869515120983,0.13173149526119232,1],[7,-0.0000013871498367734603,0.0000508426564920228,1,0,0.000014142070540401619,-1,0.00005084267468191683,0,1,0.000014142141480988357,0.000001386430767524871,0,-0.6972938179969788,0.012252187356352806,-0.0000015907206716292421,1],[7,0.000005865495495527284,0.00004619177707354538,1,0,0.04137587174773216,-0.999143660068512,0.000045909531763754785,0,0.999143660068512,0.04137587174773216,-0.0000077716977102682,0,-1.2332038879394531,-0.04537811130285263,0.000009300540114054456,1],[7,-0.9939773082733154,-0.04073113948106766,0.10173580050468445,0,-0.04034213349223137,0.9991686940193176,0.0058790696784853935,0,-0.1018906757235527,0.0017394224414601922,-0.9947940707206726,0,0.08962707221508026,-0.026956522837281227,1.151218056678772,1],[7,0.9939769506454468,0.0407383032143116,0.10173574835062027,0,-0.04034925997257233,0.999168336391449,-0.0058797989040613174,0,-0.1018906682729721,0.0017394222086295485,0.9947940707206726,0,0.08962714672088623,-0.02695651724934578,-1.151218056678772,1],[7,-0.0000017243122556465096,-0.000006312663117569173,1,0,-0.021783754229545593,-0.9997624754905701,-0.000006348728675220627,0,0.9997624754905701,-0.021783754229545593,0.0000015863898852330749,0,-1.194482445716858,0.03256598860025406,-0.0000019504564079397824,1],[7,-9.503946962752252e-9,-0.000006361991836456582,1,0,-0.002537183463573456,-0.9999967813491821,-0.000006361995474435389,0,0.9999967813491821,-0.002537183463573456,-6.637624228034156e-9,0,-0.7027315497398376,0.014433943666517735,8.326090750188087e-8,1],[7,0.9999451637268066,0.0011893251212313771,0.010407991707324982,0,-0.0012396005913615227,0.9999875426292419,0.004825334530323744,0,-0.010402125306427479,-0.004837971646338701,0.9999340772628784,0,-0.13480444252490997,-0.013655818067491055,-1.1438937187194824,1],[7,-0.008561311289668083,0.012128631584346294,-0.9998897910118103,0,-0.004232523962855339,-0.9999178647994995,-0.01209273375570774,0,-0.9999544620513916,0.004128527361899614,0.008611942641437054,0,0.6962359547615051,0.010902836918830872,-0.13173040747642517,1],[7,0.9995231032371521,0.029071778059005737,0.010407991707324982,0,-0.02912321873009205,0.9995641112327576,0.004825334530323744,0,-0.010263174772262573,-0.005126147996634245,0.9999340772628784,0,-0.38957729935646057,-0.02452850341796875,-1.1438937187194824,1],[7,0.9972234964370728,-0.07073569297790527,0.02327745594084263,0,-0.021258877590298653,0.02915710210800171,0.9993486404418945,0,-0.07136833667755127,-0.9970687031745911,0.027572384104132652,0,-0.571235179901123,1.1797314882278442,-0.057915568351745605,1],[7,0.0000018788273337122519,0.00950954295694828,-0.9999547600746155,0,-0.000014098336578172166,-0.9999547600746155,-0.00950954295694828,0,-1,0.000014115566045802552,-0.000001744673568282451,0,0.10318773239850998,0.03951199725270271,-0.1309489756822586,1],[7,-0.00984950177371502,0.011108075268566608,-0.9998897910118103,0,0.10631988942623138,-0.9942584037780762,-0.012092828750610352,0,-0.9942831993103027,-0.10642727464437485,0.008611940778791904,0,0.3553161919116974,0.05048729479312897,-0.13173040747642517,1],[7,-0.9999450445175171,-0.0012881484581157565,0.010408468544483185,0,-0.0013384196208789945,0.9999873638153076,-0.004824305884540081,0,-0.010402124375104904,-0.004837971646338701,-0.9999340772628784,0,-0.13480249047279358,-0.01367136836051941,1.1438937187194824,1],[7,-0.9995201826095581,-0.029170557856559753,0.01040846761316061,0,-0.029221994802355766,0.9995612502098083,-0.004824305884540081,0,-0.010263174772262573,-0.005126147996634245,-0.9999340772628784,0,-0.38957488536834717,-0.024543991312384605,1.1438937187194824,1],[7,-0.9972212910652161,0.07073280215263367,0.023376211524009705,0,-0.021357422694563866,0.029164092615246773,-0.9993463158607483,0,-0.07136832922697067,-0.9970687031745911,-0.0275723859667778,0,-0.5712329149246216,1.1797308921813965,0.05793106555938721,1],[7,0.9835432767868042,-0.1787930130958557,0.02599557861685753,0,-0.021260229870676994,0.02835066057741642,0.9993718266487122,0,-0.17941774427890778,-0.9834780097007751,0.02408292144536972,0,-0.5590296983718872,1.2480849027633667,-0.05608287453651428,1],[7,0.9852404594421387,-0.1692265272140503,0.025760283693671227,0,-0.021260056644678116,0.028351563960313797,0.9993718266487122,0,-0.16985060274600983,-0.9851692318916321,0.024335341528058052,0,-0.5227319598197937,1.2371981143951416,-0.07769044488668442,1],[7,-0.9835411310195923,0.17879019677639008,0.026094337925314903,0,-0.021357420831918716,0.028368329629302025,-0.9993693232536316,0,-0.1794177144765854,-0.9834780097007751,-0.02408292330801487,0,-0.559027373790741,1.2480840682983398,0.05609836429357529,1],[7,-0.9852383732795715,0.16922372579574585,0.02585904486477375,0,-0.021357420831918716,0.028368286788463593,-0.9993692636489868,0,-0.16985060274600983,-0.9851692318916321,-0.0243353433907032,0,-0.5227298140525818,1.2371972799301147,0.07770594209432602,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[57,"Skin-1",914284537,["Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand","Bip01/Bip01 Pelvis/Bip01 Spine/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand"],[[[7,-0.9972212910652161,0.07073280215263367,0.023376211524009705,0,-0.021357422694563866,0.029164092615246773,-0.9993463158607483,0,-0.07136832922697067,-0.9970687031745911,-0.0275723859667778,0,-0.5699863433837891,1.1780288219451904,0.11625837534666061,1],[7,0.9972234964370728,-0.07073569297790527,0.02327745594084263,0,-0.021258877590298653,0.02915710210800171,0.9993486404418945,0,-0.07136833667755127,-0.9970687031745911,0.027572384104132652,0,-0.5699944496154785,1.1780297756195068,-0.11624301970005035,1]],8,8]]],0,0,[],[],[]],[[[33,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{"USE_ALBEDO_MAP":true},{},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[8,6],[65,0]],[[[33,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{"USE_ALBEDO_MAP":true},{},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[8,6],[66,0]],[[[33,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{"HAS_SECOND_UV":true,"USE_ALBEDO_MAP":true},{},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[8,6],[67,0]],[[{"name":"redblue","rect":{"x":10,"y":0,"width":1669,"height":1245},"offset":{"x":2,"y":4},"originalSize":{"width":1685,"height":1253},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[3],0,[0],[11],[68]],[[[28,"player_blue"],[47,"player_blue",[[-3,-4,[48,"Dummy_ball",-6,[0,"c0Vg2ea11ANYDG2iOH2PzG",-5,0]]],1,1,4],[[70,true,false,-2,[1,"57FGriRHBaGLpGiH9fJYnh"],[3,4,5,6,7,8,9,10,11,12,13,14,15]]],[0,"ff35WAxT1Ul7D6wG+gDQYZ",-1,0],[1,0,0,28],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[31,"Bip01 Pelvis",[-7,-8,-9],[0,"78Kk+weHFfdIMu8+FZwRiY",1,0],[1,-2.38418573772492e-9,-0.0011781358625739813,-7.629394360719743e-8],[3,-0.5000006631012023,-0.49999932199667485,-0.499999292194352,0.5000007227058479],[1,-89.99999487735566,-89.99984119809935,-0.0000017075402189495764]],[6,"Bip01 Spine",2,[-10,-11,-12],[0,"78+5TeXDxbN66ertwa0f5Q",1,0],[1,0.0055677033960819244,-0.0003765177680179477,-0.000009474754733673763],[3,0.006185202759122735,0.048699109957307876,0.12600217555446833,0.9908146101626356],[1,-0.0009237367740082856,5.627829881829226,14.494793129923595]],[31,"Bip01 L Hand",[-13,-14],[0,"d4KvSmIt5cT4ZApoebztzu",1,0],[1,0.25255653262138367,-7.629394360719743e-8,0],[3,-0.6554790196693331,-0.030115377422082146,-0.3441724807410603,0.6715546309248415],[1,-96.09459577485248,-32.854980070702496,-25.010304396689936]],[31,"Bip01 R Hand",[-15,-16],[0,"a9Zk+FGNlbuKY70ycsirCi",1,0],[1,0.25255662202835083,3.814697180359872e-8,7.105427198782324e-17],[3,0.7033935667527508,0.1284220197157317,-0.26590436251814326,0.6465602408877272],[1,97.6264653247762,33.19392588432115,-9.391751626957756]],[6,"Bip01",1,[2],[0,"23SOiLJlhTaa3n5VQuHara",1,0],[1,0.0011706282384693623,0.7784847021102905,-0.00006189870327943936],[3,0.5448971270555572,0.4682852522573813,0.5029548295682065,-0.48045029176685594],[1,-95.72704220546849,-86.81781659959945,1.5497526298870348]],[6,"Bip01 Neck",3,[-17],[0,"19tEG1Hn9eWY8yO2AcTwxD",1,0],[1,0.4921576678752899,0.004864463582634926,-0.000002571195409473148],[3,0.04290756262952485,0.02058394092063683,0.0252704511680931,0.9985472681566607],[1,4.862560102540894,2.2346847452485847,2.994144221877177]],[16,"Bip01 Head",7,[[23,"Bip01 HeadNub",-18,[0,"25mSQgTL1ZjYSXq6cJVTLf",1,0],[1,0.4308357238769531,9.53674295089968e-9,3.552713599391162e-17]]],[0,"12bHt6QrhaSpUNWGc3Xldk",1,0],[1,0.039125822484493256,1.907348590179936e-8,1.776356799695581e-17],[3,-0.13447596060568745,-0.05548953235164991,-0.14743204335703167,0.9783153481419695],[1,-16.891730533959947,-8.864735321331683,-15.87538668364434]],[6,"Bip01 L Clavicle",3,[-19],[0,"48S157hklcmZ5kzs8xIUQs",1,0],[1,0.4516083598136902,-0.012276649475097656,0.029130801558494568],[3,0.614231007885865,0.1059905916806379,0.7774257285057733,0.08423479141049901],[1,-176.35781561858622,-103.86084828649889,15.139972216061024]],[6,"Bip01 L UpperArm",9,[-20],[0,"deYvatZuRaLrv68TukiBWf",1,0],[1,0.11830057203769684,-1.907348590179936e-8,0],[3,0.11808933398198838,0.36335838088846284,0.08353396562088025,0.9203519287889035],[1,9.28591958400456,41.95735168128716,13.861681617323258]],[6,"Bip01 L Forearm",10,[4],[0,"f8hTG4LZRbRphmpwRXdLLB",1,0],[1,0.25530532002449036,0,0],[3,-1.4237388936237812e-18,-5.592502475196377e-17,0.8805885104623536,-0.47388171017849295],[1,180,180,-56.57312647111236]],[16,"Bip01 L Finger0",4,[[23,"Bip01 L Finger0Nub",-21,[0,"60TOZmlyNfbYBBv1HWNYu7",1,0],[1,0.10331199318170547,-3.814697180359872e-8,-1.4210854397564648e-16]]],[0,"58QZfQoZ1awqL+GHiYbr1q",1,0],[1,0.07214080542325974,-7.105427198782324e-17,-3.814697180359872e-8],[3,-0.00039812179547901727,1.4904125640608516e-8,-7.444647418823864e-9,0.9999999207495147],[1,-0.0456213984313964,0.0000017075472225111888,-8.537736335512049e-7]],[16,"Bip01 L Finger1",4,[[23,"Bip01 L Finger1Nub",-22,[0,"c8CPb7A+tXlL6fNdNRgkJI",1,0],[1,0.10687568783760071,-3.814697180359872e-8,-7.629394360719743e-8]]],[0,"a7dR9SkIZYBajY66udFPK8",1,0],[1,0.07167846709489822,0.0006313705234788358,0.021634826436638832],[3,-0.0003981441472168258,1.4904125640475882e-8,-7.444646974668412e-9,0.9999999207406156],[1,-0.04562395975208181,0.0000017075472034329276,-8.537736208213878e-7]],[6,"Bip01 R Clavicle",3,[-23],[0,"c1BytVJrpW9IlMhkwyHjh6",1,0],[1,0.45160841941833496,-0.01227649673819542,-0.02913086861371994],[3,-0.6838445644693675,0.11528795180882723,0.7119839171906407,-0.11020073264410532],[1,-179.18836425087892,92.44080615224583,-18.336690610480556]],[6,"Bip01 R UpperArm",14,[-24],[0,"eckBF0AhJbKKttt28luY8z",1,0],[1,0.11830057203769684,3.814697180359872e-8,-1.4210854397564648e-16],[3,-0.3631718509524952,-0.4031382261690234,0.15984136098462784,0.8246432662646398],[1,-34.456376758617324,-41.337078790439286,33.81003271413883]],[6,"Bip01 R Forearm",15,[5],[0,"9bFaYqyChfY59Alb4jBscY",1,0],[1,0.2553054094314575,-7.629394360719743e-8,7.105427198782324e-17],[3,-3.616810840714558e-18,-1.9290012401901035e-17,-0.8253053445621281,0.5646867168945866],[1,-180,-180,-68.76107840101615]],[16,"Bip01 R Finger0",5,[[30,"Bip01 R Finger0Nub",-25,[0,"e3rvwV0y1Sm6hugWhYmEHq",1,0],[1,0.10331201553344727,0,1.4210854397564648e-16],[3,7.450580596923828e-9,4.562165038977444e-25,1,-6.123234262925839e-17],[1,-1,-1,-1],[1,-180,-179.99999914622634,-7.0167096047110005e-15]]],[0,"fdjhHGBLVRHqqHKfsq5KHF",1,0],[1,0.0721408873796463,1.4210854397564648e-16,1.4210854397564648e-16],[3,0.00039812921695446166,-7.453546078213996e-9,-7.447613490576177e-9,0.9999999207465602],[1,0.04562224886991161,-8.537736208172892e-7,-8.537736207970288e-7]],[16,"Bip01 R Finger1",5,[[30,"Bip01 R Finger1Nub",-26,[0,"baiqamLjBQz5RKMZCgQBsm",1,0],[1,0.10687566548585892,7.629394360719743e-8,-7.629394360719743e-8],[3,-7.450580596923828e-9,-3.469447282825859e-17,1,-7.450580596923828e-9],[1,-1,-1.0000001192092896,-1],[1,180,179.99999914622634,-8.537736462515939e-7]]],[0,"d8C7mOY3lXm5UHPXUIChkl",1,0],[1,0.07167850434780121,0.0006314087077043951,-0.021634826436638832],[3,0.00039815901927153937,-7.453546078125555e-9,-7.447613490487807e-9,0.9999999207346946],[1,0.045625663964158805,-8.537735953627242e-7,-8.537736462313321e-7]],[6,"Bip01 L Thigh",2,[-27],[0,"06//swxr5du4krd2hgb5l5",1,0],[1,-1.5258788721439487e-7,2.0742416495522775e-7,0.1258874386548996],[3,-0.1348426063413046,0.9834635995447685,0.07523845989614135,-0.09463611381490548],[1,-7.327965175591944,-170.05317385124434,-16.228344923236463]],[6,"Bip01 L Calf",19,[-28],[0,"141Joly0peo7qYaqpozJAT",1,0],[1,0.3375164270401001,-1.907348590179936e-8,0],[3,1.9779241633007607e-17,-6.4896785565582584e-18,-0.31175371877442515,0.9501629433051557],[1,2.385416263074054e-15,7.855124317273805e-24,-36.329899104889755]],[6,"Bip01 L Foot",20,[-29],[0,"12F9BLnbFahomhselvozdM",1,0],[1,0.2580810487270355,3.814697180359872e-8,-3.552713599391162e-17],[3,0.028680729125050125,-0.044580221761534596,0.08601258063011458,0.9948828351006443],[1,3.7657200527503165,-5.451189556921288,9.705714728893218]],[16,"Bip01 L Toe0",21,[[30,"Bip01 L Toe0Nub",-30,[0,"feDJEeu6tU84jN2td5CXas",1,0],[1,0.13195955753326416,2.38418573772492e-9,-1.907348590179936e-8],[3,5.3551048040390015e-9,1.862645149230957e-9,1,7.450580596923828e-9],[1,-1,-1,-1],[1,-179.9999997865566,-179.9999993863502,8.537736473946058e-7]]],[0,"e6KoGOnZhc6IllXqapHTlV",1,0],[1,0.1066858321428299,0.18787610530853271,0],[3,-0.010015184113674172,-0.011061658211018439,0.8493673847163346,0.5275911121170694],[1,178.93671737938615,179.3093883490468,63.696444692646544]],[6,"Bip01 R Thigh",2,[-31],[0,"63YoYbwihfVq+C1uJb1ubA",1,0],[1,2.288818308215923e-7,-1.406669554171458e-7,-0.1258874237537384],[3,0.1940873079822511,0.9764843995856716,-0.07963301091918047,-0.049668076447141364],[1,8.49661779274763,-175.88996697436087,22.76528046580491]],[6,"Bip01 R Calf",23,[-32],[0,"d7AoqkFvBRSYr1NLXpzFqG",1,0],[1,0.3375163972377777,0,1.776356799695581e-17],[3,4.303235122230545e-18,6.033345841197668e-18,-0.8295652345482472,0.5584098151258727],[1,180,180,-67.8917940965223]],[6,"Bip01 R Foot",24,[-33],[0,"243XxYtCxegK+dy/qNdun+",1,0],[1,0.25808098912239075,7.105427198782324e-17,-9.53674295089968e-9],[3,0.048719372105094326,0.1057958294128115,0.12837627399606044,0.9848620195415342],[1,4.089481092363769,11.714621432387062,15.258506239142363]],[16,"Bip01 R Toe0",25,[[23,"Bip01 R Toe0Nub",-34,[0,"c7Q00V9XJQ35bdhmC54uG4",1,0],[1,0.13195957243442535,4.76837147544984e-9,-9.53674295089968e-9]]],[0,"5cLoA5EsFavIlrolfDjTNK",1,0],[1,0.10668587684631348,0.1878761500120163,1.776356799695581e-17],[3,-0.00019861398289968836,-0.00019443783061864564,0.7251815783847774,0.6885576236726878],[1,179.99060378085323,179.97753714721676,87.03208521643715]],[10,"player_uniform_lod0",1,[[54,1,-35,[1,"f5E/zK38hWx7N0DvHJ2ykh"],[0],[4],1,1,2]],[0,"c5E76aQ+1bt5PAvFsp8p+o",1,0],[1,2.551235889214354e-9,2.551235889214354e-9,-0.05836546793580055],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,2,1,0,0,1,0,-1,6,0,-2,27,0,2,1,0,3,1,0,-1,3,0,-2,19,0,-3,23,0,-1,7,0,-2,9,0,-3,14,0,-1,12,0,-2,13,0,-1,17,0,-2,18,0,-1,8,0,3,8,0,-1,10,0,-1,11,0,3,12,0,3,13,0,-1,15,0,-1,16,0,3,17,0,3,18,0,-1,20,0,-1,21,0,-1,22,0,3,22,0,-1,24,0,-1,25,0,-1,26,0,3,26,0,0,27,0,10,1,2,3,6,4,3,11,5,3,16,35],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,1,13,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13],[69,16,17,18,21,28,29,10,19,20,30,31,32,33,34,35]],[[{"name":"loading_bar","rect":{"x":0,"y":0,"width":32,"height":32},"offset":{"x":0,"y":0},"originalSize":{"width":32,"height":32},"rotated":false,"capInsets":[11,14,11,14],"packable":true}],[3],0,[0],[11],[70]],[[{"fmt":"0","w":0,"h":0},-1],[4],0,[],[],[]],[[{"name":"default_sprite","rect":{"x":0,"y":2,"width":40,"height":36},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[3],0,[0],[11],[71]],[[[11,".bin",146615430,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.6755273342132568,0,-1.106397271156311],"maxPosition",8,[1,0.6755175590515137,0,0.954907238483429]]],-1],0,0,[],[],[]],[[[20,"graffiti2",[{"rasterizerState":{},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthWrite":false}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"albedoScale",8,[1,1,1,1],"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[72,0]],[[[20,"metal",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"albedoScale",8,[1,0.5882353186607361,0.5882353186607361,0.5882353186607361]]],11]]],0,0,[0],[6],[0]],[[[11,".bin",3819594787,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":14976,"length":2784,"count":696,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":14976,"count":312,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-58.33968734741211,-38.41865539550781,-1.2687495946884155],"maxPosition",8,[1,58.334205627441406,38.41865539550781,2.2058310508728027]]],-1],0,0,[],[],[]],[[[20,"graffiti1",[{"rasterizerState":{},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthWrite":false}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"albedoScale",8,[1,1,1,1],"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[73,0]],[[[11,".bin",357641497,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8208,"length":2880,"count":720,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":8208,"count":171,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.12656737864017487,-0.13218750059604645,-0.7290285229682922],"maxPosition",8,[1,0.12585937976837158,0.1243579089641571,0.7413827776908875]]],-1],0,0,[],[],[]],[[[11,".bin",3774146780,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0,-1.3316034078598022,-1.3528767824172974],"maxPosition",8,[1,0,1.33160400390625,1.352876901626587]]],-1],0,0,[],[],[]],[[[11,".bin",1485473625,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":384,"length":48,"count":12,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":384,"count":8,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-25.292661666870117,-15.738018035888672,-1.1900564432144165],"maxPosition",8,[1,25.945297241210938,15.738018035888672,1.1900564432144165]]],-1],0,0,[],[],[]],[[[20,"grass",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"HAS_SECOND_UV":true,"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"tilingOffset",8,[2,10,10,-4.5,-4.5],"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[74,0]],[[[20,"DOT",[{"rasterizerState":{},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthWrite":false}}],[{"HAS_SECOND_UV":true,"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"albedoScale",8,[1,1,1,1],"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[75,0]],[[[11,".bin",3499688527,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":384,"length":48,"count":12,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":384,"count":8,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-25.292661666870117,-15.738016128540039,-1.1900564432144165],"maxPosition",8,[1,25.976181030273438,15.738018035888672,1.1900564432144165]]],-1],0,0,[],[],[]],[[[11,".bin",1476549747,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":504,"length":96,"count":24,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":504,"count":9,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-58.179813385009766,-39.14060974121094,0],"maxPosition",8,[1,58.20182800292969,39.118038177490234,0]]],-1],0,0,[],[],[]],[[[11,".bin",1367772641,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1176,"length":192,"count":48,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1176,"count":21,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-66.29959106445312,-44.820064544677734,0],"maxPosition",8,[1,66.28109741210938,44.795867919921875,0]]],-1],0,0,[],[],[]],[[[20,"outer",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"HAS_SECOND_UV":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"albedoScale",8,[1,0.7490196228027344,0.46274513006210327,0.3960784673690796]]],11]]],0,0,[0],[6],[0]],[[[11,".bin",1231223116,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.6755175590515137,0,-1.106397271156311],"maxPosition",8,[1,0.6755224466323853,0,1.106397271156311]]],-1],0,0,[],[],[]],[[[11,".bin",1796499211,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":384,"length":48,"count":12,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":384,"count":8,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-25.981748580932617,-15.738016128540039,-1.1900564432144165],"maxPosition",8,[1,25.292665481567383,15.738018035888672,1.1900564432144165]]],-1],0,0,[],[],[]],[[[20,"wall",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"albedoScale",8,[1,0.4941176772117615,0.4745098352432251,0.458823561668396]]],11]]],0,0,[0],[6],[0]],[[[11,".bin",3295812957,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":14784,"length":1848,"count":462,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":14784,"count":308,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.7037326097488403,-1.5946918725967407,0],"maxPosition",8,[1,1.1511033773422241,0.9434395432472229,17.896381378173828]]],-1],0,0,[],[],[]],[[[11,".bin",3460400357,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":45696,"length":5184,"count":1296,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":51648,"length":72,"count":18,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":45696,"count":714,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false},{"name":"a_texCoord2","format":21,"isNormalized":false}]},{"view":{"offset":50880,"length":768,"count":12,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false},{"name":"a_texCoord2","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-55.17036437988281,-36.086917877197266,-0.00584901450201869],"maxPosition",8,[1,55.21807098388672,36.270668029785156,0.00584901450201869]]],-1],0,0,[],[],[]],[[[20,"graffiti3",[{"rasterizerState":{},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthWrite":false}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"albedoScale",8,[1,1,1,1],"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[76,0]],[[[11,".bin",1598536799,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.593027949333191,0,-1.6171319484710693],"maxPosition",8,[1,1.593043565750122,0,1.6171319484710693]]],-1],0,0,[],[],[]],[[[20,"cage",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"albedoScale",8,[1,0.5879999995231628,0.5879999995231628,0.5879999995231628]]],11]]],0,0,[0],[6],[0]],[[[11,".bin",2958836760,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":14784,"length":1848,"count":462,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":14784,"count":308,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.6600643396377563,-1.060881495475769,0],"maxPosition",8,[1,1.039819598197937,1.6516919136047363,17.896381378173828]]],-1],0,0,[],[],[]],[[[20,"corner_flag",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[77,0]],[[[11,".bin",3372507450,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":40992,"length":14880,"count":3720,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":40992,"count":854,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.2234277725219727,-4.12562370300293,-1.4570523500442505],"maxPosition",8,[1,1.2234277725219727,4.12562370300293,1.4570523500442505]]],-1],0,0,[],[],[]],[[[11,".bin",3443375674,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.593027949333191,0,-1.6171319484710693],"maxPosition",8,[1,1.593043565750122,0,1.6171319484710693]]],-1],0,0,[],[],[]],[[[11,".bin",1005417063,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":149952,"length":54912,"count":13728,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":149952,"count":3124,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-58.31077194213867,-38.40055847167969,1.0305312871932983],"maxPosition",8,[1,58.28852844238281,38.40055847167969,3.4257280826568604]]],-1],0,0,[],[],[]],[[[11,".bin",3182073153,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":14784,"length":1848,"count":462,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":14784,"count":308,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.0398199558258057,-1.6516917943954468,0],"maxPosition",8,[1,1.6600645780563354,1.0608811378479004,17.896381378173828]]],-1],0,0,[],[],[]],[[[20,"light",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[78,0]],[[[11,".bin",735786311,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":384,"length":48,"count":12,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":384,"count":8,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-25.968496322631836,-15.738018035888672,-1.1900564432144165],"maxPosition",8,[1,25.292665481567383,15.738018035888672,1.1900564432144165]]],-1],0,0,[],[],[]],[[[20,"wire",[{"rasterizerState":{},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthWrite":false}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"albedoScale",8,[1,1,1,1],"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[79,0]],[[[11,".bin",1592949934,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0,-1.2254828214645386,-1.2440193891525269],"maxPosition",8,[1,0,1.2254828214645386,1.2440195083618164]]],-1],0,0,[],[],[]],[[[11,".bin",2320269657,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":14784,"length":1848,"count":462,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":14784,"count":308,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.0608811378479004,-1.0398198366165161,0],"maxPosition",8,[1,1.6516917943954468,1.6600645780563354,17.896381378173828]]],-1],0,0,[],[],[]],[[[11,".bin",552685569,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":40992,"length":14880,"count":3720,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":40992,"count":854,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.2234277725219727,-4.12562370300293,-1.4570523500442505],"maxPosition",8,[1,1.2234277725219727,4.12562370300293,1.4570523500442505]]],-1],0,0,[],[],[]],[[[20,"LINE",[{"rasterizerState":{},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthWrite":false}}],[{"HAS_SECOND_UV":true,"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"albedoScale",8,[1,1,1,1],"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[80,0]],[[[28,"LabalTip"],[90,"LabalTip",33554432,[[5,-2,[1,"b7RBTdEZ9Bb4IqqB3h4mvi"],[5,612,138.67]],[44,"球出界啦！！",100,100,100,false,-3,[1,"10kIqSPWpBbrVt7KK94C2p"],[4,4284862973],0],[39,4,-4,[1,"e6ymjQaERD6btSmRECD/79"],[4,4282466732]],[40,-5,[1,"7eU0wXGshE/JXVVVUxakTF"],[0,2,-2.67]],[125,17,-0.14074074074074072,0.2,false,false,1,-6,[1,"d2JrpfPfdKlLbUFoSuCj+D"]]],[0,"f9Z13xQv9K67+NLpRWQ8in",-1,0],[1,0,437.33000000000004,0],[1,2,2,2]]],0,[0,2,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,10,1,6],[0],[14],[9]],[[[61],[51,"ground",[-2],[0,"0dbpdUWKdV57/5BohZgCIy",-1,0]],[64,"Node-0",1,[[12,-3,[1,"25Ytm+qdtZ0YMYY4L3LoS0"],[0,1],[4],2]],[0,"d9n/ByaxZTcpE638qd/q2M",1,0]]],0,[0,2,1,0,-1,2,0,0,2,0,10,1,3],[0,0,0],[-1,-2,1],[81,82,83]],[[[11,".bin",2242281877,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":3648,"length":240,"count":120,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":9648,"length":1728,"count":864,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":3648,"count":76,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":3888,"length":5760,"count":240,"stride":24},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false}]}]},"minPosition",8,[1,-144.7083282470703,0.0004844574141316116,-146.51644897460938],"maxPosition",8,[1,144.69503784179688,0.0005312944995239377,146.51991271972656]]],-1],0,0,[],[],[]],[[[11,".bin",1429551580,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":18720,"length":4992,"count":1248,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":18720,"count":390,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.1047295555472374,-0.1047295406460762,-0.10492683202028275],"maxPosition",8,[1,0.1047295555472374,0.1047295406460762,0.10492686182260513]]],-1],0,0,[],[],[]],[[[20,"ground",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"albedoScale",8,[1,0.41568630933761597,0.3803921937942505,0.38431376218795776]]],11]]],0,0,[0],[6],[0]],[[[24,"GoalCheer",".mp3",3.648],-1],0,0,[],[],[]],[[{"name":"LOGO","rect":{"x":2,"y":0,"width":627,"height":511},"offset":{"x":-0.5,"y":0},"originalSize":{"width":632,"height":511},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[3],0,[0],[11],[84]],[[{"name":"loading_bg","rect":{"x":0,"y":0,"width":32,"height":32},"offset":{"x":0,"y":0},"originalSize":{"width":32,"height":32},"rotated":false,"capInsets":[7,13,8,13],"packable":true}],[3],0,[0],[11],[85]],[[{"fmt":"0","w":0,"h":0},-1],[4],0,[],[],[]],[[{"name":"default_sprite_splash","rect":{"x":0,"y":0,"width":2,"height":2},"offset":{"x":0,"y":0},"originalSize":{"width":2,"height":2},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[3],0,[0],[11],[86]],[[[141,"playLeveL"],[91,"netTarget",[[-7,[34,"Bone_main",-8,[1,0.30371588468551636,0.073094941675663,-1.7945640706784616e-7],[3,-0.011902316178749546,0.9999291649259837,-2.275274490217451e-8,7.575267869733691e-8],[1,0.42511752247810364,0.4251174330711365,0.42511746287345886],[1,0.000002504477963783574,179.9999913485787,-1.36393717196104]],[34,"Bone001",-9,[1,0.4108210802078247,2.389219045639038,-1.5403921338474902e-7],[3,-0.011902184880872434,0.9999291664888345,-2.2752736054918103e-8,7.575267872885982e-8],[1,0.425117552280426,0.42511752247810364,0.7990496754646301],[1,0.000002504478078189943,179.9999913485784,-1.3639221252667826]],[34,"Bone002",-10,[1,0.10981658846139908,1.232712984085083,3.82535457611084],[3,-0.7071067811865476,4.745407724032793e-15,4.745407724032793e-15,0.7071067811865476],[1,0.42511746287345886,0.42511746287345886,0.7990497350692749],[1,-90.00000000000003,7.690262401376427e-13,0]],[34,"Bone006",-11,[1,0.10981658846139908,1.232712984085083,-3.709669589996338],[3,-0.7071067811865476,4.745407724032793e-15,4.745407724032793e-15,0.7071067811865476],[1,0.42511746287345886,0.42511746287345886,0.7990497350692749],[1,-90.00000000000003,7.690262401376427e-13,0]],[34,"Bone003",-12,[1,-0.39680755138397217,1.313459038734436,2.5713002681732178],[3,-0.011902183018491193,0.9999291665110025,-2.2752736056456603e-8,7.575268592284202e-8],[1,0.42511749267578125,0.42511746287345886,1.0157394409179688],[1,0.000002504478084558592,179.99999134857757,-1.363921911838495]],[34,"Bone004",-13,[1,-0.39680784940719604,1.313459038734436,-1.5546969223123597e-7],[3,-0.011902184880872434,0.9999291664888345,-2.2752736055952185e-8,7.575267881573542e-8],[1,0.425117552280426,0.42511752247810364,0.7990496754646301],[1,0.000002504478078189943,179.9999913485784,-1.3639221252667826]],[34,"Bone005",-14,[1,-0.39680755138397217,1.313459038734436,-2.300687551498413],[3,-0.011902183018491193,0.9999291665110025,-2.2752736056456603e-8,7.575268592284202e-8],[1,0.42511749267578125,0.42511746287345886,1.0157394409179688],[1,0.000002504478084558592,179.99999134857757,-1.363921911838495]],-15],1,4,4,4,4,4,4,4,1],[[116,-1],[59,true,-2,[1,0.2,1.3,-3.75],[1,1.78,2.5,0.2]],[17,4,2,-3],[59,true,-4,[1,-0.7,1.3,0],[1,0.2,2.5,7.45]],[59,true,-5,[1,0.2,1.3,3.75],[1,1.78,2.5,0.2]],[142,-6,[1,0.1,2.52,0],[1,1.91,0.1,7.47]]]],[144,"playLeveL",[-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38],[112,[[29,["lineDrawer"],-17,-16,[2,["1afkG6oWpFNbWz//Z8fTX2"]]],[29,["goalKeeperAnim"],-19,-18,[2,["6bR8fWh5ZDApbCnaDhxFqy"]]],[29,["audioManager"],-21,-20,[2,["62Yq9c9lJIOKy/toURuWzA"]]],[29,["uiManager"],-23,-22,[2,["70Ze/ifsFLgKT510rWBiyv"]]]]],[145,[146,10000],[147,true,2,3,40,356.3,0.7,[4,4283190348],[0,2048,2048]],[148,true,true,81],[149]]],[52,"Boundary",[-39,-40,-41,-42,-43,-44,-45,-46,-47,-48]],[52,"RedTeam",[-49,-50,-51,-52,-53,-54,-55,-56,-57,-58]],[52,"YellowTeam",[-59,-60,-61,-62,-63,-64,-65,-66,-67,-68]],[9,0,null,2,[114,"744g86bFFFfbNAmpp5A/wy",-80,[80,"a1DPIk8TZH3ZDGWDCapW1o",null,[[19,"MainCanvas",["_name"],[2,["744g86bFFFfbNAmpp5A/wy"]]],[13,["_lpos"],[2,["744g86bFFFfbNAmpp5A/wy"]],[1,540,960,0]],[13,["_lrot"],[2,["744g86bFFFfbNAmpp5A/wy"]],[3,0,0,0,1]],[3,["_euler"],-78,[1,0,0,0]],[19,true,["_active"],[2,["d9ACc9GBBDp6cIL4o7Vt72","47EKbKsbRNHZVmWwrmZ/Si"]]],[19,true,["_active"],[2,["68zKWSASJN1opULcb9w7tV"]]],[19,true,["_active"],[2,["2beBBKkqJAZrRFDXhaNAur","a2dB6QwRBP8pLu2mgFdr8K"]]],[19,true,["_active"],[2,["2beBBKkqJAZrRFDXhaNAur","4a0gysKblHHq7Zx8XvlFqJ"]]],[13,["_contentSize"],[2,["2beBBKkqJAZrRFDXhaNAur","acUC4hoVBDpIRgUJCoJq4O"]],[5,1280,2400]],[7,true,["_active"],-79]]],[[25,["labelTip"],-69,[2,["10kIqSPWpBbrVt7KK94C2p"]]],[79,["currentLevelLabl"],[2,["fdiySMBXJB3Lk5g/gHBO69"]]],[25,["progressBar"],-70,[2,["55hxuuz8hEIbMBQc78zk4O"]]],[25,["backGroundLayout"],-71,[2,["0bKE5MLrRAyJj89BkMTxFB"]]],[25,["labelTip"],-72,[2,["10kIqSPWpBbrVt7KK94C2p"]]],[25,["currentLevelLabl"],-73,[2,["fdiySMBXJB3Lk5g/gHBO69"]]],[25,["transitionAnim"],-74,[2,["e2sIoC0pFAL4K2EanJsF59"]]],[25,["progressBar"],-75,[2,["55hxuuz8hEIbMBQc78zk4O"]]],[25,["backGroundLayout"],-76,[2,["0bKE5MLrRAyJj89BkMTxFB"]]],[25,["BGBlackMask"],-77,[2,["16mfhnIyVK1p65txBB3/iv"]]]],76]],[101,"ball","830aI3QRtGW5FO4WTzip29",2,[-85],[[118,8,false,0.05,0.2,-81],[151,-82,[4,5]],[121,true,0.1,-83],[153,1000,2,true,1000,0,[null,null],-84,[154,[4,1810623467]],[60,0.1],[32],[32],[32],[32],[32],[32],[32],[60,0.5],[32],[60,10],[32],[155,2]]],[1,-7.883,0.583,-38.672],[1,1.5,1.5,1.5]],[102,"mesh_cage02",[-87,-88,-89,-90],[[78,1,-86,[41],[4],42]],[1,0.2685803833007796,1.4575275182724,-1.2494227874526586e-14],[3,-4.329780281177468e-17,0.7071067811865472,0.7071067811865478,4.3297802811774646e-17],[1,-90.00000000000004,180,0]],[103,"GoalTarget","bfSJTgswlGTL2UalQcKKsJ",2,[1,-91,8,-92],[1,0,0,-56.269],[3,0,-0.7071067811865477,0,0.7071067811865474],[1,0,-90.00000000000003,0]],[104,"PillarsParent",9,[-93,-94,-95]],[156],[2,["f9Z13xQv9K67+NLpRWQ8in"]],[65,0,null,[8,"a2dB6QwRBP8pLu2mgFdr8K",-98,[81,"2beBBKkqJAZrRFDXhaNAur",6,[[85,[null],[2,["e7TEiF9VNM46wSvyBZacGM"]]]],[[19,"background_Layout",["_name"],[2,["a2dB6QwRBP8pLu2mgFdr8K"]]],[13,["_lpos"],[2,["a2dB6QwRBP8pLu2mgFdr8K"]],[1,0,0,0]],[13,["_lrot"],[2,["a2dB6QwRBP8pLu2mgFdr8K"]],[3,0,0,0,1]],[3,["_euler"],-96,[1,0,0,0]],[19,1,["_alignMode"],[2,["84TpvgoHJNOJVMMIMWnjdB"]]],[19,false,["_active"],[2,["4a0gysKblHHq7Zx8XvlFqJ"]]],[19,false,["_active"],[2,["e7TEiF9VNM46wSvyBZacGM"]]],[7,true,["_active"],-97]]],78]],[2,["4dNUz8+2VGxavTeHG7Yr/S"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[2,["ff35WAxT1Ul7D6wG+gDQYZ"]],[106,"goalSocreJudgePlane",9,[[[18,"Cube<ModelComponent>",false,-99,[31],[4],32],-100,[17,16,2,-101]],4,1,4],[1,0.7,0.986,0],[3,-4.32978028117747e-17,0.7071067811865472,0.7071067811865478,4.329780281177466e-17],[1,0.711,7.232,2.906],[1,-90.00000000000006,180,-7.062250076880254e-31]],[38,"Cube",8,[[18,"Cube<ModelComponent>",false,-102,[33],[4],34],[45,-103],[17,16,2,-104]],[1,-0.01,0.101,1.217],[1,1.703,7.704,0.354]],[22,"Cube-001",8,[[18,"Cube<ModelComponent>",false,-105,[35],[4],36],[45,-106],[17,16,2,-107]],[1,0.231,3.937,-0.083],[3,0.7071067811865475,0,0,0.7071067811865476],[1,2.564,2.855,0.354],[1,90,0,0]],[22,"Cube-003",8,[[18,"Cube<ModelComponent>",false,-108,[37],[4],38],[45,-109],[17,16,2,-110]],[1,0.231,-3.952,-0.083],[3,0.7071067811865475,0,0,0.7071067811865476],[1,2.564,2.855,0.354],[1,90,0,0]],[22,"Cube-004",8,[[18,"Cube<ModelComponent>",false,-111,[39],[4],40],[45,-112],[17,16,2,-113]],[1,1.066,-0.039,-0.083],[3,0.5,0.4999999999999999,0.5,0.5000000000000001],[1,8.215,2.855,0.354],[1,90,0,90]],[38,"Pillars",10,[[18,"Cube<ModelComponent>",false,-114,[43],[4],44],[21,true,-115],[17,4,2,-116]],[1,1.338,1.372,3.915],[1,0.196,3.449,0.5]],[38,"Pillars-001",10,[[18,"Cube<ModelComponent>",false,-117,[45],[4],46],[21,true,-118],[17,4,2,-119]],[1,1.338,1.372,-3.942],[1,0.196,3.449,0.5]],[22,"Pillars-002",10,[[18,"Cube<ModelComponent>",false,-120,[47],[4],48],[21,true,-121],[17,4,2,-122]],[1,1.374,2.786,-0.031],[3,0.7071067811865475,0,0,0.7071067811865476],[1,0.196,8,0.5],[1,89.99999999999999,0,0]],[38,"Cube",3,[[18,"Cube<ModelComponent>",false,-123,[49],[4],50],[21,true,-124],[17,4,2,-125]],[1,-39.5,5.159,0],[1,2.368,38.326,319.665]],[38,"Cube-001",3,[[18,"Cube<ModelComponent>",false,-126,[51],[4],52],[21,true,-127],[17,4,2,-128]],[1,40.961,5.159,0],[1,5.144,38.326,265.111]],[22,"Cube-002",3,[[18,"Cube<ModelComponent>",false,-129,[53],[4],54],[21,true,-130],[17,4,2,-131]],[1,-0.228,5.159,59.138],[3,0,0.7071067811865475,0,0.7071067811865476],[1,3.736,38.326,184.93],[1,0,90,0]],[22,"Cube-004",3,[[18,"Cube<ModelComponent>",false,-132,[55],[4],56],[21,true,-133],[17,4,2,-134]],[1,2.347,5.159,-59.509],[3,0,0.7071067811865475,0,0.7071067811865477],[1,2.453,38.326,184.021],[1,0,89.99999999999999,0]],[22,"Cube-005",3,[[18,"Cube<ModelComponent>",false,-135,[57],[4],58],[21,true,-136],[17,4,2,-137]],[1,-35.593,0,-88.66],[3,0,0.7071067811865475,0,0.7071067811865477],[1,67.23,0.5,63.308],[1,0,89.99999999999999,0]],[22,"Cube-006",3,[[18,"Cube<ModelComponent>",false,-138,[59],[4],60],[21,true,-139],[17,4,2,-140]],[1,65.618,0,-6.331],[3,0,0.7071067811865475,0,0.7071067811865476],[1,258.801,0.5,58.983],[1,0,89.99999999999999,0]],[22,"Cube-007",3,[[18,"Cube<ModelComponent>",false,-141,[61],[4],62],[21,true,-142],[17,4,2,-143]],[1,-65.568,0,-6.331],[3,0,0.7071067811865475,0,0.7071067811865476],[1,258.801,0.5,58.983],[1,0,89.99999999999999,0]],[22,"Cube-008",3,[[18,"Cube<ModelComponent>",false,-144,[63],[4],64],[21,true,-145],[17,4,2,-146]],[1,12.116,0,100.108],[3,0,0.7071067811865475,0,0.7071067811865476],[1,89.91,0.5,198.719],[1,0,89.99999999999999,0]],[22,"Cube-009",3,[[18,"Cube<ModelComponent>",false,-147,[65],[4],66],[21,true,-148],[17,4,2,-149]],[1,35.572,0,-88.66],[3,0,0.7071067811865475,0,0.7071067811865477],[1,67.23,0.5,63.308],[1,0,89.99999999999999,0]],[22,"Cube-010",3,[[18,"Cube<ModelComponent>",false,-150,[67],[4],68],[21,true,-151],[17,4,2,-152]],[1,1.927,0,-90.49],[3,0,0.7071067811865475,0,0.7071067811865477],[1,67.23,0.5,63.308],[1,0,89.99999999999999,0]],[2,["dcfO1udnBGtbVnyY8L6YOs"]],[9,0,null,2,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-154,[15,"b5fyrcsxxOSrFMMJ0jYbgd",[[7,"goalKeeper",["_name"],15],[3,["_lpos"],15,[1,0,0,28]],[3,["_lrot"],15,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],15,[1,0,180,0]],[150,["soccerAI"],[2,["6bR8fWh5ZDApbCnaDhxFqy"]],-153],[13,["_lrot"],[2,["b56BG2F+9N7qKK7KVECKY7"]],[3,0.43232201570465795,0.33125116731003057,0.7602687181449208,-0.35406472959613444]]]],1]],[157,7,[-165,-166,-167,-168,-169,-170,-171,-172,-173,-174],[-155,-156,-157,-158,-159,-160,-161,-162,-163,-164]],[9,0,null,4,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-175,[15,"7dG72VyURBZYSuTpno0H1g",[[7,"player_blue",["_name"],35],[3,["_lpos"],35,[1,0,0,28]],[3,["_lrot"],35,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],35,[1,0,180,0]]]],25]],[105,"AIPlayers","c4CtgyL1pIuq91qC+P7aW4",2,[4,5],[1,0,-0.15,0]],[9,0,null,5,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-176,[15,"e483yAnohBpJQ7wHzxqv0O",[[7,"player_red",["_name"],16],[3,["_lpos"],16,[1,0,0,28]],[3,["_lrot"],16,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],16,[1,0,180,0]]]],6]],[9,0,null,5,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-177,[15,"83W6iMoAVCBJqDy7hmOU3r",[[7,"player_red-001",["_name"],17],[3,["_lpos"],17,[1,0,0,28]],[3,["_lrot"],17,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],17,[1,0,180,0]]]],7]],[9,0,null,5,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-178,[15,"83W6iMoAVCBJqDy7hmOU3r",[[7,"player_red-002",["_name"],18],[3,["_lpos"],18,[1,0,0,28]],[3,["_lrot"],18,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],18,[1,0,180,0]]]],8]],[9,0,null,5,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-179,[15,"83W6iMoAVCBJqDy7hmOU3r",[[7,"player_red-003",["_name"],19],[3,["_lpos"],19,[1,0,0,28]],[3,["_lrot"],19,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],19,[1,0,180,0]]]],9]],[9,0,null,5,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-180,[15,"83W6iMoAVCBJqDy7hmOU3r",[[7,"player_red-004",["_name"],20],[3,["_lpos"],20,[1,0,0,28]],[3,["_lrot"],20,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],20,[1,0,180,0]]]],10]],[9,0,null,5,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-181,[15,"83W6iMoAVCBJqDy7hmOU3r",[[7,"player_red-005",["_name"],21],[3,["_lpos"],21,[1,0,0,28]],[3,["_lrot"],21,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],21,[1,0,180,0]]]],11]],[9,0,null,5,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-182,[15,"83W6iMoAVCBJqDy7hmOU3r",[[7,"player_red-006",["_name"],22],[3,["_lpos"],22,[1,0,0,28]],[3,["_lrot"],22,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],22,[1,0,180,0]]]],12]],[9,0,null,5,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-183,[15,"83W6iMoAVCBJqDy7hmOU3r",[[7,"player_red-007",["_name"],23],[3,["_lpos"],23,[1,0,0,28]],[3,["_lrot"],23,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],23,[1,0,180,0]]]],13]],[9,0,null,5,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-184,[15,"83W6iMoAVCBJqDy7hmOU3r",[[7,"player_red-008",["_name"],24],[3,["_lpos"],24,[1,0,0,28]],[3,["_lrot"],24,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],24,[1,0,180,0]]]],14]],[9,0,null,5,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-185,[15,"83W6iMoAVCBJqDy7hmOU3r",[[7,"player_red-009",["_name"],25],[3,["_lpos"],25,[1,0,0,28]],[3,["_lrot"],25,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],25,[1,0,180,0]]]],15]],[9,0,null,4,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-186,[15,"2acY2R0yROcbTAjH75gQ6X",[[7,"player_blue-001",["_name"],26],[3,["_lpos"],26,[1,0,0,28]],[3,["_lrot"],26,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],26,[1,0,180,0]]]],16]],[9,0,null,4,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-187,[15,"2acY2R0yROcbTAjH75gQ6X",[[7,"player_blue-002",["_name"],27],[3,["_lpos"],27,[1,0,0,28]],[3,["_lrot"],27,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],27,[1,0,180,0]]]],17]],[9,0,null,4,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-188,[15,"2acY2R0yROcbTAjH75gQ6X",[[7,"player_blue-003",["_name"],28],[3,["_lpos"],28,[1,0,0,28]],[3,["_lrot"],28,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],28,[1,0,180,0]]]],18]],[9,0,null,4,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-189,[15,"2acY2R0yROcbTAjH75gQ6X",[[7,"player_blue-004",["_name"],29],[3,["_lpos"],29,[1,0,0,28]],[3,["_lrot"],29,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],29,[1,0,180,0]]]],19]],[9,0,null,4,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-190,[15,"2acY2R0yROcbTAjH75gQ6X",[[7,"player_blue-005",["_name"],30],[3,["_lpos"],30,[1,0,0,28]],[3,["_lrot"],30,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],30,[1,0,180,0]]]],20]],[9,0,null,4,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-191,[15,"2acY2R0yROcbTAjH75gQ6X",[[7,"player_blue-006",["_name"],31],[3,["_lpos"],31,[1,0,0,28]],[3,["_lrot"],31,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],31,[1,0,180,0]]]],21]],[9,0,null,4,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-192,[15,"2acY2R0yROcbTAjH75gQ6X",[[7,"player_blue-007",["_name"],32],[3,["_lpos"],32,[1,0,0,28]],[3,["_lrot"],32,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],32,[1,0,180,0]]]],22]],[9,0,null,4,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-193,[15,"2acY2R0yROcbTAjH75gQ6X",[[7,"player_blue-008",["_name"],33],[3,["_lpos"],33,[1,0,0,28]],[3,["_lrot"],33,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],33,[1,0,180,0]]]],23]],[9,0,null,4,[8,"ff35WAxT1Ul7D6wG+gDQYZ",-194,[15,"2acY2R0yROcbTAjH75gQ6X",[[7,"player_blue-009",["_name"],34],[3,["_lpos"],34,[1,0,0,28]],[3,["_lrot"],34,[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],34,[1,0,180,0]]]],24]],[108,"ColliderManager","32gzadAN1IEqCDiu7bcnT3",2,[3],[-195]],[68,"GameManager","bePx6pSp5BFouSNL5arERR",2,[11,-196]],[49,"rookieTip","fbVOMDMOdNArtO5257QNz4",2,[[58,"Plane<ModelComponent>",-197,[69],[4],70]],[1,-2,0.583,-48.59],[1,0.175,0.175,0.175]],[49,"JudgeRangeAngle","e2O5wM/bFNtLXU+wTYB3PV",2,[[58,"Plane<ModelComponent>",-198,[71],[4],72]],[1,0,0.2,0],[1,5.724,5.724,5.724]],[49,"JudgeRangePlane","ca5fbTajFOPIIboDu4z0KS",2,[[58,"Plane<ModelComponent>",-199,[73],[4],74]],[1,0,0.2,0],[1,5.724,5.724,5.724]],[107,"PlayerCam","d2ibL4ccROq7IqSsQYtNal",2,[[-200,[158,-202,-201,82,81]],1,4],[1,0,15,22.47],[3,-0.2896081835266615,0,0,0.9571452867952637],[1,-33.669,0,0]],[9,0,null,2,[8,"dcfO1udnBGtbVnyY8L6YOs",-203,[15,"375sD8U5tBPYXFLNT99Len",[[7,"AudioMgr",["_name"],54],[3,["_lpos"],54,[1,0,0,0]],[3,["_lrot"],54,[3,0,0,0,1]],[3,["_euler"],54,[1,0,0,0]]]],75]],[65,0,{},[8,"f9Z13xQv9K67+NLpRWQ8in",-204,[37,"70LDbTgqFFRIutXfrVL/sn",6,[[7,"LabalTip",["_name"],12],[3,["_lpos"],12,[1,0,581.33,0]],[3,["_lrot"],12,[3,0,0,0,1]],[3,["_euler"],12,[1,0,0,0]],[7,true,["_active"],12]]],77]],[92,"New Node"],[9,0,null,86,[8,"4dNUz8+2VGxavTeHG7Yr/S",-205,[82,"a9xwYUg39JiLB7ueJImVrM",6,[[86,[null],[2,["4dNUz8+2VGxavTeHG7Yr/S"]]]],[[7,"TransitionAnime",["_name"],14],[3,["_lpos"],14,[1,0,0,0]],[3,["_lrot"],14,[3,0,0,0,1]],[3,["_euler"],14,[1,0,0,0]],[13,["_contentSize"],[2,["d9T5wnqTNJjYYAmZApPIA4"]],[5,1517.037037037037,3000]],[13,["_contentSize"],[2,["b8vNFz4MZCT7PbIPt9mRqu"]],[5,1517.037037037037,3000]],[13,["_lpos"],[2,["3b8StDe7VDx6i4XlOVkS2R"]],[1,0,600,0]],[13,["_lpos"],[2,["575ExsP75HSZiAgXf5pBAs"]],[1,0,-85.8075,0]],[13,["_lpos"],[2,["e1LlONd8hIeaHitPZb82EM"]],[1,0,-619.065,0]],[13,["_color"],[2,["f0pzkuDVtOgKjj07ChPoZw"]],[4,0]],[19,false,["_active"],[2,["b1a9zjvWBBRoAerlCAQOvW"]]],[7,true,["_active"],14]]],79]],[93,"Main Light","c0y6F5f+pAvI805TdmxIjx",2,[[159,14992,50000,-206,[160]]],[1,-19.678,8.149,0],[3,-0.29572301232933784,-0.4042998328344751,-0.1456631268452455,0.8531540298366665],[1,-38.492,-50.9,-0.54]],[9,0,null,2,[8,"d2BiTHE0NNzoEz9Y+vLYIg",-207,[80,"b7Cn/9C61GhY01h6wxT7Bl",null,[[19,"Scenary",["_name"],[2,["d2BiTHE0NNzoEz9Y+vLYIg"]]],[13,["_lpos"],[2,["d2BiTHE0NNzoEz9Y+vLYIg"]],[1,0,0,0]],[13,["_lrot"],[2,["d2BiTHE0NNzoEz9Y+vLYIg"]],[3,0,0,0,1]],[13,["_euler"],[2,["d2BiTHE0NNzoEz9Y+vLYIg"]],[1,0,0,0]]]],0]],[68,"SoccerAI","c8+j1vwR9JjL2fsAMvmd5R",2,[56]],[94,"temp",7,[[78,1,-208,[2],[4],3]],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000003,0,0]],[95,"mesh_net001",1,[[123,-209,[26],[4],1,27,28]],[1,1.1853680610656738,0,0],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000004,0,0]],[22,"Plane",1,[[18,"Plane<ModelComponent>",false,-210,[29],[4],30]],[1,1.372,1.268,0],[3,0,0,-0.7071067811865475,0.7071067811865476],[1,0.281,1,0.754],[1,0,0,-90]],[21,true,36],[161,78,3,1,94,10],[162,79],[163,"Camera<CameraComponent>",60,1822425087,83,[4,4286073907]],[2,["744g86bFFFfbNAmpp5A/wy"]],[2,["a2dB6QwRBP8pLu2mgFdr8K"]],[9,0,null,6,[8,"47EKbKsbRNHZVmWwrmZ/Si",-215,[37,"d9ACc9GBBDp6cIL4o7Vt72",6,[[19,"BGBlackMask",["_name"],[2,["47EKbKsbRNHZVmWwrmZ/Si"]]],[13,["_lpos"],[2,["47EKbKsbRNHZVmWwrmZ/Si"]],[1,0,0,0]],[13,["_lrot"],[2,["47EKbKsbRNHZVmWwrmZ/Si"]],[3,0,0,0,1]],[3,["_euler"],-211,[1,0,0,0]],[3,["_color"],-212,[4,16777215]],[7,true,["_active"],-213],[7,null,["_spriteFrame"],-214]]],80]],[2,["47EKbKsbRNHZVmWwrmZ/Si"]],[2,["44C3xIdK1N8pANk1B9iSHZ"]]],0,[0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,92,0,3,1,0,3,1,0,3,1,0,3,1,0,3,1,0,3,1,0,3,1,0,-9,93,0,7,6,0,12,11,0,7,55,0,12,11,0,7,84,0,12,11,0,7,6,0,12,11,0,-1,88,0,-2,89,0,-3,55,0,-4,9,0,-5,78,0,-6,79,0,-7,7,0,-8,81,0,-9,82,0,-10,83,0,-11,90,0,-12,58,0,-13,84,0,-14,80,0,-15,6,0,-1,44,0,-2,45,0,-3,46,0,-4,47,0,-5,48,0,-6,49,0,-7,50,0,-8,51,0,-9,52,0,-10,53,0,-1,57,0,-2,69,0,-3,70,0,-4,71,0,-5,72,0,-6,73,0,-7,74,0,-8,75,0,-9,76,0,-10,77,0,-1,59,0,-2,60,0,-3,61,0,-4,62,0,-5,63,0,-6,64,0,-7,65,0,-8,66,0,-9,67,0,-10,68,0,7,85,0,7,13,0,7,13,0,7,85,0,7,87,0,7,87,0,7,13,0,7,13,0,7,100,0,9,98,0,9,98,0,2,6,0,0,7,0,0,7,0,0,7,0,0,7,0,-1,91,0,0,8,0,-1,37,0,-2,38,0,-3,39,0,-4,40,0,-2,36,0,-4,10,0,-1,41,0,-2,42,0,-3,43,0,9,99,0,9,99,0,2,13,0,0,36,0,-2,94,0,0,36,0,0,37,0,0,37,0,0,37,0,0,38,0,0,38,0,0,38,0,0,39,0,0,39,0,0,39,0,0,40,0,0,40,0,0,40,0,0,41,0,0,41,0,0,41,0,0,42,0,0,42,0,0,42,0,0,43,0,0,43,0,0,43,0,0,44,0,0,44,0,0,44,0,0,45,0,0,45,0,0,45,0,0,46,0,0,46,0,0,46,0,0,47,0,0,47,0,0,47,0,0,48,0,0,48,0,0,48,0,0,49,0,0,49,0,0,49,0,0,50,0,0,50,0,0,50,0,0,51,0,0,51,0,0,51,0,0,52,0,0,52,0,0,52,0,0,53,0,0,53,0,0,53,0,19,56,0,2,55,0,-1,59,0,-2,60,0,-3,61,0,-4,62,0,-5,63,0,-6,64,0,-7,65,0,-8,66,0,-9,67,0,-10,68,0,-1,57,0,-2,69,0,-3,70,0,-4,71,0,-5,72,0,-6,73,0,-7,74,0,-8,75,0,-9,76,0,-10,77,0,2,57,0,2,59,0,2,60,0,2,61,0,2,62,0,2,63,0,2,64,0,2,65,0,2,66,0,2,67,0,2,68,0,2,69,0,2,70,0,2,71,0,2,72,0,2,73,0,2,74,0,2,75,0,2,76,0,2,77,0,-1,95,0,-2,96,0,0,80,0,0,81,0,0,82,0,-1,97,0,20,97,0,0,83,0,2,84,0,2,85,0,2,87,0,0,88,0,2,89,0,0,91,0,0,92,0,0,93,0,9,101,0,9,102,0,9,101,0,9,102,0,2,100,0,21,2,1,3,9,3,3,78,4,3,58,5,3,58,8,3,9,11,22,80,11,23,96,11,24,95,11,25,56,11,0,79,13,3,86,56,0,90,85,3,86,215],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[5,5,-1,1,-1,-2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,-1,1,13,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,5,5,5,5,5,5,26],[87,88,89,90,91,92,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,93,94,95,1,11,1,2,1,2,1,2,1,2,1,2,36,96,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,97,11,98,11,99,11,100,101,37,38,39,40,102]],[[[28,"TransitionAnime"],[50,"TransitionAnime",33554432,[-7,-8,-9,-10],[[5,-2,[1,"d9T5wnqTNJjYYAmZApPIA4"],[5,1280,2400]],[36,0,-3,[1,"f0pzkuDVtOgKjj07ChPoZw"],[4,0],4],[83,-4,[1,"e2sIoC0pFAL4K2EanJsF59"],[5,6],7],[42,-5,[1,"33qzOn7aFDl5D+GoPMFzbD"]],[43,45,-0.09259259259259259,-0.09259259259259259,-0.125,-0.125,false,false,false,false,2000,2800,1,-6,[1,"0bcHVfs3JFpLQkTnrqaPdL"]]],[0,"4dNUz8+2VGxavTeHG7Yr/S",-1,0]],[41,"LevelID",33554432,1,[[5,-11,[1,"37WDaZ88xHdbqhqCxJQUlg"],[5,396.59,390.67]],[44,"{0}",280,280,300,false,-12,[1,"fdiySMBXJB3Lk5g/gHBO69"],[4,4284862973],3],[39,4,-13,[1,"91yEmCiOJPXpPBAJ+ERfbC"],[4,4282466732]],[40,-14,[1,"15nrc1eN1Ogqx4V/uDHasd"],[0,2,-2.67]],[55,18,-0.206355,false,false,1,-15,[1,"bd11C6IJJOX7mHu5qfVBpf"]],[152,-16,[1,"74u0tsKT5LlZBERdj6+rtb"]]],[0,"e1LlONd8hIeaHitPZb82EM",1,0],[1,0,-495.252,0]],[41,"Level",33554432,1,[[5,-17,[1,"ddAWRb/dhIfpUL5LRmdjnQ"],[5,539.15,201.67]],[44,"Level",200,200,150,false,-18,[1,"78bckkst9EvJ3CTC/HJ6Z2"],[4,4284862973],2],[39,4,-19,[1,"1c0CjXJ/FNT78P/OJHytMs"],[4,4282466732]],[40,-20,[1,"80eZ/qVptIap2p+nAO7T+K"],[0,2,-2.67]],[55,18,-0.028602500000000003,false,false,1,-21,[1,"0af/i25tBHz6J8M7r7o2oO"]]],[0,"575ExsP75HSZiAgXf5pBAs",1,0],[1,0,-68.646,0]],[35,"BGBlack",33554432,1,[[5,-22,[1,"b8vNFz4MZCT7PbIPt9mRqu"],[5,1280,2400]],[36,0,-23,[1,"6dC71+6uJHlp+nM8oWmD8i"],[4,4278190080],0],[126,45,false,false,false,false,100,100,1,-24,[1,"8dJD+qpehNB4c8XwPr4vXY"]]],[0,"b1a9zjvWBBRoAerlCAQOvW",1,0]],[41,"Logo",33554432,1,[[5,-25,[1,"67P/Qw9BJI8ZvQLilvO+AM"],[5,627,511]],[136,0,-26,[1,"32I5nB1CBOn72Z0q9K5uuP"],1],[55,18,0.2,false,false,1,-27,[1,"79lrWUraRNS46LW7O6NKGd"]]],[0,"3b8StDe7VDx6i4XlOVkS2R",1,0],[1,0,480,0]]],0,[0,2,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,4,0,-2,5,0,-3,3,0,-4,2,0,0,2,0,0,2,0,0,2,0,0,2,0,0,2,0,0,2,0,0,3,0,0,3,0,0,3,0,0,3,0,0,3,0,0,4,0,0,4,0,0,4,0,0,5,0,0,5,0,0,5,0,10,1,27],[0,0,0,0,0,0,0,0],[4,4,14,14,4,-1,-2,15],[8,22,9,9,103,41,104,41]],[[{"fmt":"0","w":0,"h":0},-1],[4],0,[],[],[]],[[[46,"1",[{"priority":10000,"stage":200,"rasterizerState":{},"depthStencilState":{"depthWrite":true,"depthFunc":7},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[105,15]],[[[24,"sfx_move_5",".mp3",0.36],-1],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[4],0,[],[],[]],[[{"name":"background","rect":{"x":0,"y":1,"width":180,"height":1593},"offset":{"x":0,"y":-0.5},"originalSize":{"width":180,"height":1594},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[3],0,[0],[11],[106]],[[[24,"FailSigh",".mp3",2.299],-1],0,0,[],[],[]],[[[24,"sfx_shortpass_1",".mp3",0.36],-1],0,0,[],[],[]],[[[165,"LuckiestGuy-Regular","LuckiestGuy-Regular.ttf"],-1],0,0,[],[],[]],[[[46,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"mainColor",8,[4,1299674999],"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[107,15]],[[[77,"builtin-unlit",[{"hash":1017648509,"name":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nlayout(location = 0) out float v_fog_factor;\n#if USE_VERTEX_COLOR\n  layout(location = 13) in lowp vec4 a_color;\n  layout(location = 1) out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  layout(location = 2) out vec2 v_uv;\n  layout(set = 1, binding = 0) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(matWorld * position);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(matWorld * position);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(matWorld * position);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(matWorld * position);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  layout(location = 2) in vec2 v_uv;\n  layout(set = 1, binding = 2) uniform sampler2D mainTexture;\n#endif\nlayout(set = 1, binding = 1) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  layout(location = 1) in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nout float v_fog_factor;\n#if USE_VERTEX_COLOR\n  in lowp vec4 a_color;\n  out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  out vec2 v_uv;\n  layout(std140) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(matWorld * position);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(matWorld * position);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(matWorld * position);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(matWorld * position);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n#endif\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvarying float v_fog_factor;\n#if USE_VERTEX_COLOR\n  attribute lowp vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n      uniform vec4 tilingOffset;\n#endif\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(matWorld * position);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(matWorld * position);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(matWorld * position);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(matWorld * position);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_fogColor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\n   uniform vec4 mainColor;\n   uniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":195,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":["USE_TEXTURE"]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r","g","b"]}],"blocks":[{"name":"TexCoords","stageFlags":1,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1}],"defines":["USE_TEXTURE"]},{"name":"Constant","stageFlags":16,"binding":1,"members":[{"name":"mainColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_TEXTURE"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":13,"defines":["USE_VERTEX_COLOR"]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":1,"location":1,"defines":["USE_VERTEX_COLOR"]},{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":2,"defines":["USE_TEXTURE"]}]}],[{"name":"opaque","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"transparent","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"add","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]}]]],0,0,[],[],[]],[[[24,"sfx_move_6",".mp3",0.252],-1],0,0,[],[],[]],[[[24,"sfx_move_4",".mp3",0.324],-1],0,0,[],[],[]],[[[20,"BG",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[8,6],[108,0]],[[[11,".bin",901920506,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1824,"length":432,"count":108,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1824,"count":38,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-233.80679321289062,-230.2547607421875,0],"maxPosition",8,[1,233.80679321289062,230.25474548339844,92.59278106689453]]],-1],0,0,[],[],[]],[[[28,"MainCanvas"],[110,"MainCanvas",33554432,[-24,-25,-26,-27],[[[5,-17,[1,"e1agzvmj5B/Lpgnf8Q8B3y"],[5,1080,1920]],[166,-19,[1,"74pqM/VitLa5W+ARbXeYJC"],-18],[127,45,1,-20,[1,"dfP6EkqE5M2YbEylqoBrtP"]],[167,-22,[1,"1afkG6oWpFNbWz//Z8fTX2"],-21],-23],4,4,4,4,1],[113,"744g86bFFFfbNAmpp5A/wy",-16,0,[[25,["labelTip"],-1,[2,["10kIqSPWpBbrVt7KK94C2p"]]],[79,["currentLevelLabl"],[2,["fdiySMBXJB3Lk5g/gHBO69"]]],[25,["progressBar"],-2,[2,["55hxuuz8hEIbMBQc78zk4O"]]],[25,["backGroundLayout"],-3,[2,["0bKE5MLrRAyJj89BkMTxFB"]]],[29,["labelTip"],-5,-4,[2,["10kIqSPWpBbrVt7KK94C2p"]]],[29,["currentLevelLabl"],-7,-6,[2,["fdiySMBXJB3Lk5g/gHBO69"]]],[29,["transitionAnim"],-9,-8,[2,["e2sIoC0pFAL4K2EanJsF59"]]],[29,["progressBar"],-11,-10,[2,["55hxuuz8hEIbMBQc78zk4O"]]],[29,["backGroundLayout"],-13,-12,[2,["0bKE5MLrRAyJj89BkMTxFB"]]],[29,["BGBlackMask"],-15,-14,[2,["16mfhnIyVK1p65txBB3/iv"]]]]],[1,540,960,0]],[69,"Canvas",33554432,1,[-30,-31,-32,-33,-34,-35],[[[5,-28,[1,"8aX1Y5KHJHXpOZQVwDM2K6"],[5,1280,2400]],-29],4,1],[0,"04sBH4nmJMMJKFfD3UoPb4",1,0]],[69,"PlayAgain",33554432,2,[-41,-42,-43],[[[5,-36,[1,"2bXqLvcJJMh7ti316Es3SY"],[5,1280,2400]],[128,45,false,100,100,1,-37,[1,"565qPvhvRPw78KodFUpyZC"]],-38,[84,-39,[1,"47undtJKxD/KBQyY9j9v/Z"],[5,6]],[137,-40,[1,"c9jhXZ6IlLWqf7SwgrLQso"],[4,16777215]]],4,4,1,4,4],[0,"11ZXA9tLRFEJz4+kt4VxQg",1,0]],[111,"PlayAgainBtn",33554432,2,[-49],[[[5,-44,[1,"83QtSoIC9OlqNGL8ERp70Z"],[5,100,40]],[56,1,0,-45,[1,"a3X8iX5gRHSq/E4nATxTx6"],8],-46,[129,20,0.2,false,false,1,-47,[1,"e181pihNhKdKDqJWqsRtMO"]],[83,-48,[1,"0f2SMsVVtFM4X+Gs90KIbL"],[9,10],11]],4,4,1,4,4],[0,"3dxo4SsCFJnJIeW5tPBneZ",1,0],[1,0,-560,0],[1,5,8,1]],[168,1,[1,"70Ze/ifsFLgKT510rWBiyv"]],[9,0,null,2,[8,"a2dB6QwRBP8pLu2mgFdr8K",-52,[81,"2beBBKkqJAZrRFDXhaNAur",1,[[85,[null],[2,["e7TEiF9VNM46wSvyBZacGM"]]]],[[19,"background_Layout",["_name"],[2,["a2dB6QwRBP8pLu2mgFdr8K"]]],[13,["_lpos"],[2,["a2dB6QwRBP8pLu2mgFdr8K"]],[1,0,0,0]],[13,["_lrot"],[2,["a2dB6QwRBP8pLu2mgFdr8K"]],[3,0,0,0,1]],[3,["_euler"],-50,[1,0,0,0]],[19,1,["_alignMode"],[2,["84TpvgoHJNOJVMMIMWnjdB"]]],[19,false,["_active"],[2,["4a0gysKblHHq7Zx8XvlFqJ"]]],[19,false,["_active"],[2,["e7TEiF9VNM46wSvyBZacGM"]]],[7,true,["_active"],-51]]],0]],[35,"Level",33554432,3,[[5,-53,[1,"90UG8n9p1CVYmGpklItpBv"],[5,731.5,505.67]],[44,"ALL\nLEVELS\nCOMPLETE!",150,150,150,false,-54,[1,"aaJ0g8cSlBPoUaL5IGr7hb"],[4,4284862973],4],[130,18,0.3956588541666666,false,false,false,1,-55,[1,"280Kc5AmVFibn/Pi9v4ihC"]],[39,6,-56,[1,"1c0CjXJ/FNT78P/OJHytMs"],[4,4282466732]],[40,-57,[1,"80eZ/qVptIap2p+nAO7T+K"],[0,2,-2.67]]],[0,"cad9LjkRpFx7Eh53I2LRST",1,0]],[53,"RestartBtn",33554432,2,[[[5,-58,[1,"c8TLhvjgdFD4aB96ZXvrIS"],[5,148,161]],[56,1,0,-59,[1,"f2tdHnyJVOcY6MJLWREMuO"],12],-60,[131,9,0.15,0.15,false,false,1,-61,[1,"7d/+ac6jxD2LlMzPbhBhBe"]]],4,4,1,4],[0,"8cPdbqXg1GfL4l57iSzhsT",1,0],[1,-374,759.5,0]],[2,["f9Z13xQv9K67+NLpRWQ8in"]],[96,"Label",512,33554432,4,[[5,-62,[1,"46rsXU6t9EFZNDLT9sz6Ur"],[5,400,200]],[139,"PLAY\nAGAIN",100,100,100,1,false,false,-63,[1,"94MMTf6cVNuaDtsEfwU1KP"],7],[39,4,-64,[1,"1c0CjXJ/FNT78P/OJHytMs"],[4,4282466732]],[40,-65,[1,"80eZ/qVptIap2p+nAO7T+K"],[0,2,-2.67]]],[0,"72BSY+FV9HU4pbQU7aMiLh",1,0],[1,0,2.294,0],[1,0.15,0.15,1]],[2,["4dNUz8+2VGxavTeHG7Yr/S"]],[53,"Graphics",33554432,1,[[[74,-66,[1,"9fBD/2NNBAvqDFw+lgqcDz"],[5,1080,1920],[0,0,0]],-67,[132,45,960,640,1,-68,[1,"49Zkq3hLpJ4JtOMhssLs4J"]]],4,1,4],[0,"7bkllBlmVHebHntlthb9yi",1,0],[1,-540,-960,0]],[9,0,{},2,[8,"f9Z13xQv9K67+NLpRWQ8in",-69,[37,"70LDbTgqFFRIutXfrVL/sn",1,[[7,"LabalTip",["_name"],9],[3,["_lpos"],9,[1,0,581.33,0]],[3,["_lrot"],9,[3,0,0,0,1]],[3,["_euler"],9,[1,0,0,0]],[7,true,["_active"],9]]],1]],[35,"BGBlack",33554432,3,[[5,-70,[1,"ff6qv2iV9JJ4xgAU17+WUG"],[5,6000,6000]],[36,0,-71,[1,"2fns1WmbVJZY8pU0+KiNIF"],[4,4278190080],2],[43,45,-1.84375,-1.84375,-0.75,-0.75,false,false,false,false,100,100,1,-72,[1,"bbVstknnRGfKBeExodDYW6"]]],[0,"68zKWSASJN1opULcb9w7tV",1,0]],[41,"LOGO",33554432,3,[[5,-73,[1,"4d/boKiRVMFLgIQQChRL6v"],[5,627,511]],[14,-74,[1,"7dQBOBf+pLq5ShmJUXpU2K"],3],[133,17,0.17,false,1,-75,[1,"81ii5fMwxJN6/aHsvcj/ON"]]],[0,"3aSllfjZ1BSrqKWd49ZBzq",1,0],[1,0,536.5,0]],[9,0,null,2,[8,"4dNUz8+2VGxavTeHG7Yr/S",-76,[82,"a9xwYUg39JiLB7ueJImVrM",1,[[86,[null],[2,["4dNUz8+2VGxavTeHG7Yr/S"]]]],[[7,"TransitionAnime",["_name"],11],[3,["_lpos"],11,[1,0,0,0]],[3,["_lrot"],11,[3,0,0,0,1]],[3,["_euler"],11,[1,0,0,0]],[13,["_contentSize"],[2,["d9T5wnqTNJjYYAmZApPIA4"]],[5,1517.037037037037,3000]],[13,["_contentSize"],[2,["b8vNFz4MZCT7PbIPt9mRqu"]],[5,1517.037037037037,3000]],[13,["_lpos"],[2,["3b8StDe7VDx6i4XlOVkS2R"]],[1,0,600,0]],[13,["_lpos"],[2,["575ExsP75HSZiAgXf5pBAs"]],[1,0,-85.8075,0]],[13,["_lpos"],[2,["e1LlONd8hIeaHitPZb82EM"]],[1,0,-619.065,0]],[13,["_color"],[2,["f0pzkuDVtOgKjj07ChPoZw"]],[4,0]],[19,false,["_active"],[2,["b1a9zjvWBBRoAerlCAQOvW"]]],[7,true,["_active"],11]]],13]],[9,0,null,1,[8,"47EKbKsbRNHZVmWwrmZ/Si",-81,[37,"d9ACc9GBBDp6cIL4o7Vt72",1,[[19,"BGBlackMask",["_name"],[2,["47EKbKsbRNHZVmWwrmZ/Si"]]],[13,["_lpos"],[2,["47EKbKsbRNHZVmWwrmZ/Si"]],[1,0,0,0]],[13,["_lrot"],[2,["47EKbKsbRNHZVmWwrmZ/Si"]],[3,0,0,0,1]],[3,["_euler"],-77,[1,0,0,0]],[3,["_color"],-78,[4,16777215]],[7,true,["_active"],-79],[7,null,["_spriteFrame"],-80]]],14]],[109,"Camera",1,[-82],[0,"7dTojg/vdEH7F6bylkUAhM",1,0],[1,0,0,1000]],[164,0,1073741824,960,2000,6,41943040,18,[1,"33+hAubf1KwL9SsTztNnw4"],[4,4278190080]],[169,12,1,1,7,12,[1,"fex5MWVBRAEZj8Uh8oEifm"],[4,4294440951]],[2,["a2dB6QwRBP8pLu2mgFdr8K"]],[42,3,[1,"985A3diKtFbYWMSJeRGUnB"]],[170,2,4,[1,"9f9DvLnzpHXK20BrxHPc6D"],[4,4292269782],4],[171,2,8,[1,"5aCF8mmbFD4Jrk7UpDZiUM"],[[172,"0295bsDktRCyoMFBCSxST3+","Btn_Restart",1]],[4,4292269782],8],[43,45,-0.09259259259259259,-0.09259259259259259,-0.125,-0.125,false,false,false,false,1280,2400,1,2,[1,"18WnUzomNE3bOtSdy9WfLy"]],[2,["47EKbKsbRNHZVmWwrmZ/Si"]],[2,["44C3xIdK1N8pANk1B9iSHZ"]]],0,[0,7,13,0,7,6,0,7,6,0,7,13,0,12,5,0,7,16,0,12,5,0,7,16,0,12,5,0,7,6,0,12,5,0,7,6,0,12,5,0,7,17,0,12,5,0,2,1,0,0,1,0,27,19,0,0,1,0,0,1,0,28,20,0,0,1,0,-5,5,0,-1,18,0,-2,12,0,-3,2,0,-4,17,0,0,2,0,-2,25,0,-1,6,0,-2,13,0,-3,3,0,-4,4,0,-5,8,0,-6,16,0,0,3,0,0,3,0,-3,22,0,0,3,0,0,3,0,-1,14,0,-2,15,0,-3,7,0,0,4,0,0,4,0,-3,23,0,0,4,0,0,4,0,-1,10,0,9,21,0,9,21,0,2,6,0,0,7,0,0,7,0,0,7,0,0,7,0,0,7,0,0,8,0,0,8,0,-3,24,0,0,8,0,0,10,0,0,10,0,0,10,0,0,10,0,0,12,0,-2,20,0,0,12,0,2,13,0,0,14,0,0,14,0,0,14,0,0,15,0,0,15,0,0,15,0,2,16,0,9,26,0,9,27,0,9,26,0,9,27,0,2,17,0,-1,19,0,10,1,5,29,25,5,30,23,5,31,22,5,32,24,82],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,23,24,24],[5,5,4,4,14,-1,-2,14,4,-1,-2,15,4,5,5,16,17,16,17],[38,37,8,22,9,42,43,9,23,44,109,44,24,39,40,23,23,24,24]],[[[28,"AudioMgr"],[97,"AudioMgr",[[173,false,-2,[1,"42eioZyuZNSLoJ428Ru9Fr"]],[174,-3,[1,"62Yq9c9lJIOKy/toURuWzA"],[0,1,2,3,4,5,6,7,8,9,10,11]]],[0,"dcfO1udnBGtbVnyY8L6YOs",-1,0]]],0,[0,2,1,0,0,1,0,0,1,0,10,1,3],[0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12],[110,111,112,113,114,115,116,117,118,119,120,121]],[[[33,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{"USE_LIGHTMAP":true,"HAS_SECOND_UV":true},{},{},{}],[[[{},"mainColor",8,[4,4281868544],"emissive",8,[4,4289996032]],{},{},{}],11,0,0,0]]],0,0,[0],[6],[0]],[[[33,[{"rasterizerState":{"cullMode":0},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{"USE_ALBEDO_MAP":true,"USE_ALPHA_TEST":true},{},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[8,6],[122,0]],[[[28,"BGBlackMask"],[50,"BGBlackMask",33554432,[-5],[[5,-2,[1,"7bfKqU2H1Al4VYSXqteN4M"],[5,1280,2400]],[76,true,-3,[1,"f5E8yn9X9FNL8SXFSc4nD2"]],[42,-4,[1,"16mfhnIyVK1p65txBB3/iv"]]],[0,"47EKbKsbRNHZVmWwrmZ/Si",-1,0]],[35,"SpriteSplash",33554432,1,[[5,-6,[1,"7679aj+CBAeZxMTbWU+kKZ"],[5,6000,6000]],[36,0,-7,[1,"44C3xIdK1N8pANk1B9iSHZ"],[4,0],0],[43,45,-1.84375,-1.84375,-0.75,-0.75,false,false,false,false,100,100,1,-8,[1,"c5v0kCPWJK9JLF+Jx22VQy"]],[84,-9,[1,"e2hOROPiRHI7Deaks7bMqp"],[1,2]]],[0,"01CNX63iZKP7GUUmnFxmtj",1,0]]],0,[0,2,1,0,0,1,0,0,1,0,0,1,0,-1,2,0,0,2,0,0,2,0,0,2,0,0,2,0,10,1,9],[0,0,0],[4,-1,-2],[8,42,43]],[[[33,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{"USE_ALBEDO_MAP":true},{},{},{}],[[[{"roughness":0.7071067690849304,"metallic":0.4000000059604645},"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[8,6],[123,0]],[[[24,"sfx_move_3",".mp3",0.18],-1],0,0,[],[],[]],[[[28,"Scenary"],[51,"Scenary",[-2,-3,-4,-5],[0,"d2BiTHE0NNzoEz9Y+vLYIg",-1,0]],[67,"field",1,[-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31],[0,"83eYpPSklM94LMohJAkrGE",1,0],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,89.99999999999999,0]],[2,["ba6Ebf17hXjZ3btyqFSu6a"]],[2,["0dbpdUWKdV57/5BohZgCIy"]],[10,"caoping01",2,[[12,-32,[1,"41TPd5sKdKBpjx49JKkqJn"],[3],[4],4],[143,true,-33,[1,"a47xNCWtVDr7U14Wv1m7Oa"],[1,0.011007308959960938,-0.011285781860351562,0],[1,116.38164138793945,78.25864791870117,0.001]]],[0,"d2CVpg+qpJA6yiehrMwLdu",1,0],[1,0.0000049035093070415314,0.0005183848552405834,-0.000004903486569673987],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000003,0,0]],[10,"lines_002",2,[[12,-34,[1,"f0tDbuPBpFNYDcEZjeEror"],[0,1],[4],2]],[0,"19iWBvHI5IRY9rXXUVE71o",1,0],[1,-0.009404931217432022,0.015135747380554676,0.037050917744636536],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"corner_flag1",2,[[12,-35,[1,"08eEqly55BXbbUFgzlw06z"],[5],[4],6]],[0,"a54kvwt7tA4qSD8UTdmr7B",1,0],[1,54.98671340942383,0.6985926628112793,-35.962257385253906],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"corner_flag002",2,[[12,-36,[1,"fausTeTnxOR6PwmdS36diD"],[7],[4],8]],[0,"67tG6GE05DkpokJ5zG/KO8",1,0],[1,54.98507308959961,0.6985926628112793,35.99665451049805],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"corner_flag003",2,[[12,-37,[1,"47IrTtKWdJ84cdooWH93c9"],[9],[4],10]],[0,"fbeayGFfRMYY64FeRmYQiQ",1,0],[1,-54.983707427978516,0.6985926628112793,35.9755859375],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"corner_flag004",2,[[12,-38,[1,"55FAM/UANHfrQOWkvRazZ2"],[11],[4],12]],[0,"b17fZlKxtNj4n4hEoK1PYB",1,0],[1,-54.9630241394043,0.6985926628112793,-35.962432861328125],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"outer_floor",2,[[12,-39,[1,"89Ui5RcoBKoq/f6gce5b4T"],[13],[4],14]],[0,"1chpVqSApDvJ5Avy5tJ2i8",1,0],[1,0.0000049035093070415314,0.0005183848552405834,-0.000004903486569673987],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"wall",2,[[140,1,-40,[1,"8faGq5L1JD07huE4l+wRWY"],[15],[124,true,true],16]],[0,"e27xkOM/5L37e9bpX9UZba",1,0],[1,0,1.2687495946884155,0],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000003,0,0]],[10,"wire",2,[[12,-41,[1,"72jjUnnHRGQp6tekXZWNPl"],[17],[4],18]],[0,"6d//nPgGJHsa7bBWgmzLmV",1,0],[1,-32.2403564453125,2.083439588546753,-22.552940368652344],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"wire2",2,[[12,-42,[1,"bdzAYIb6lINpxjUl3rIQIR"],[19],[4],20]],[0,"9f1H1G47tA+6OYGMLyjXoJ",1,0],[1,32.240352630615234,2.083439588546753,-22.552940368652344],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"wire3",2,[[12,-43,[1,"1dyBZEk35PuLBZereolBit"],[21],[4],22]],[0,"16enlNPjNAi4qY7CetRIfV",1,0],[1,32.240352630615234,2.083439588546753,22.552940368652344],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"wire4",2,[[12,-44,[1,"49a2FaUuROYahONjWd6orv"],[23],[4],24]],[0,"7cAYW3fw1CFYmM2m1qYIOt",1,0],[1,-32.2403564453125,2.083439588546753,22.552940368652344],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"door1",2,[[12,-45,[1,"c6hz4jxONO6qdRoV3yUjre"],[25],[4],26]],[0,"27Gy0vlchHzqf2gJB/HwFF",1,0],[1,0.012996215373277664,1.0603867769241333,38.269649505615234],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"door002",2,[[12,-46,[1,"0eRV5lmwNEb6HL8lYSJPes"],[27],[4],28]],[0,"03Nsd5WwtGmI52350VNXz/",1,0],[1,-0.010397377423942089,1.0603867769241333,-38.25852584838867],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[62,"metal_rod",2,[[12,-47,[1,"a9NqVR/5ZAJaIpoCFcNs+g"],[29],[4],30]],[0,"31xT2XQo5HbIBaZFry5OZV",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"graffiti1",2,[[12,-48,[1,"eeV7nc6r1Ktas4YRMj2IXN"],[31],[4],32]],[0,"561Vz6ek5O/pbgJ+afD5ad",1,0],[1,-57.958988189697266,2.155442476272583,5.000444412231445],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"graffiti002",2,[[12,-49,[1,"0aiHBtseNM1auvGJzDEQk7"],[33],[4],34]],[0,"e9hvGp+HxKFYEo/dxVCInV",1,0],[1,57.983436584472656,1.832588791847229,4.68576192855835],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"graffiti003",2,[[12,-50,[1,"d1GW96d9lGEKiC4z8PJ9IF"],[35],[4],36]],[0,"cdGYhSxfFHQKgwUwyKEz1r",1,0],[1,-3.7778480052948,1.7911370992660522,-38.0859260559082],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"graffiti004",2,[[12,-51,[1,"63imuBsiFO9pC7ofblAqjM"],[37],[4],38]],[0,"47fLLfRi1BK4N1vquSR3YZ",1,0],[1,-4.294985771179199,1.7938873767852783,38.07197570800781],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"Light1",2,[[12,-52,[1,"dfNsrOW09KDaXoDSZpeVBj"],[39],[4],40]],[0,"07+qJsIIlIP6PriYVOmU+X",1,0],[1,-59.380714416503906,0,-40.43022537231445],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"Light002",2,[[12,-53,[1,"1cihO6DDlB8Z0hsSIDaatM"],[41],[4],42]],[0,"a1jSupdppINKo+4mUufP2r",1,0],[1,59.5262451171875,0,-40.697509765625],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"Light003",2,[[12,-54,[1,"b7bOJyEH5A8IWFzwCS1g/u"],[43],[4],44]],[0,"76yYwZdeBIVrmLoGx/4GhC",1,0],[1,59.112220764160156,0,40.40545654296875],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"Light004",2,[[12,-55,[1,"85GEqJoQFHDLTpDB9Spt7j"],[45],[4],46]],[0,"32cO+gagtN27OVamLS5Muz",1,0],[1,-59.240638732910156,0,40.4415397644043],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"mesh_cage01",2,[[12,-56,[1,"d8xV2baUVIgJrey27OLs+9"],[47],[4],48]],[0,"c07v/RC4pJZJcT5yql3dgh",1,0],[1,-56.00041961669922,1.4575275182724,0],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,-90.00000000000003,0,0]],[10,"graffiti005",2,[[12,-57,[1,"64fJNmADFMga19zEWZ1R0t"],[49],[4],50]],[0,"36tRnTJ0VDh5isEm6cqNmS",1,0],[1,57.983,1.833,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[10,"graffiti006",2,[[12,-58,[1,"18PkEeEZNASLu9Q+X5epma"],[51],[4],52]],[0,"c071gWZzBOsI9iE7/jAQJO",1,0],[1,57.983,1.833,-4.68],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,-90,0,0]],[67,"buildings_bg",1,[-59],[0,"6dhO+lDE9O8ZoRKrmvpIv9",1,0],[3,0,0.7071067811865475,0,0.7071067811865476],[1,0,89.99999999999999,0]],[10,"BG",31,[[12,-60,[1,"d2KPJ5DVVKNpLIxN49uLgK"],[53],[4],54]],[0,"c3vkzxlVtHpagbYodS2lhy",1,0],[1,0,-10.863576889038086,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[9,0,null,1,[8,"ba6Ebf17hXjZ3btyqFSu6a",-61,[37,"3bDIMYXrFPbpleuHWDfl2P",1,[[7,"buildings",["_name"],3],[3,["_lpos"],3,[1,0,0,0]],[3,["_lrot"],3,[3,0,0,0,1]],[3,["_euler"],3,[1,0,0,0]]]],55]],[9,0,null,1,[8,"0dbpdUWKdV57/5BohZgCIy",-62,[37,"e0DoShJfpMj4DNH6AgbaPD",1,[[7,"ground",["_name"],4],[3,["_lpos"],4,[1,0,0,0]],[3,["_lrot"],4,[3,0,0.7071067811865475,0,0.7071067811865476]],[3,["_euler"],4,[1,0,90,0]]]],56]]],0,[0,2,1,0,-1,2,0,-2,31,0,-3,33,0,-4,34,0,-1,6,0,-2,5,0,-3,7,0,-4,8,0,-5,9,0,-6,10,0,-7,11,0,-8,12,0,-9,13,0,-10,14,0,-11,15,0,-12,16,0,-13,17,0,-14,18,0,-15,19,0,-16,20,0,-17,21,0,-18,22,0,-19,23,0,-20,24,0,-21,25,0,-22,26,0,-23,27,0,-24,28,0,-25,29,0,-26,30,0,0,5,0,0,5,0,0,6,0,0,7,0,0,8,0,0,9,0,0,10,0,0,11,0,0,12,0,0,13,0,0,14,0,0,15,0,0,16,0,0,17,0,0,18,0,0,19,0,0,20,0,0,21,0,0,22,0,0,23,0,0,24,0,0,25,0,0,26,0,0,27,0,0,28,0,0,29,0,0,30,0,-1,32,0,0,32,0,2,33,0,2,34,0,10,1,62],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,5,5],[124,125,126,127,128,12,13,12,13,12,13,12,13,129,130,131,132,7,133,7,134,7,135,7,136,7,137,7,138,139,140,141,142,25,26,45,143,45,144,14,145,14,146,14,147,14,148,36,149,25,26,25,26,150,151,152,153]],[[[87,[{}]]],0,0,[0],[6],[0]],[[{"name":"restart","rect":{"x":0,"y":0,"width":148,"height":161},"offset":{"x":0,"y":0},"originalSize":{"width":148,"height":161},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[3],0,[0],[11],[154]],[[[11,".bin",1706823080,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":25920,"length":2160,"count":540,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":25920,"count":360,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4]]},"minPosition",8,[1,-1.9424813985824585,-3.7771739959716797,0.021980438381433487],"maxPosition",8,[1,0.05672416836023331,3.790539026260376,2.5736639499664307]]],-1],0,0,[],[],[]],[[[57,"Skin-0",1996575095,["Bone_main","Bone005","Bone004","Bone001","Bone003"],[[[7,-2.3516242504119873,-0.055991459637880325,3.6157140925752174e-7,0,3.6146889215160627e-7,8.606464874105768e-9,2.3522911071777344,0,-0.05599145218729973,2.3516244888305664,-4.4061145138731407e-17,0,-2.0692217350006104,-0.22125683724880219,-1.0335347155887575e-7,1],[7,-2.3516247272491455,-0.05599110946059227,3.560541586011823e-7,0,8.518042022842565e-7,-3.517936519870091e-8,0.9845044612884521,0,-0.05599110573530197,2.3516247272491455,2.3205277699389626e-8,0,-3.6471431255340576,-3.1773505210876465,-2.2650365829467773,1],[7,-2.3516242504119873,-0.055991049855947495,3.59495288648759e-7,0,6.765929470020637e-7,-2.9193691020168444e-8,1.2514866590499878,0,-0.055991046130657196,2.3516244888305664,2.4095697881421074e-8,0,-3.647141456604004,-3.1773500442504883,3.4256783010278014e-7,1],[7,-2.3516242504119873,-0.055991049855947495,3.59495288648759e-7,0,6.765929470020637e-7,-2.9193691020168444e-8,1.2514866590499878,0,-0.055991046130657196,2.3516244888305664,2.4095697881421074e-8,0,-1.6876685619354248,-5.661913871765137,2.8098073201476836e-8,1],[7,-2.3516247272491455,-0.05599110946059227,3.560541586011823e-7,0,8.518042022842565e-7,-3.517936519870091e-8,0.9845044612884521,0,-0.05599110573530197,2.3516247272491455,2.3205277699389626e-8,0,-3.647138833999634,-3.1773507595062256,2.5314571857452393,1]],8,8,8,8,8]]],0,0,[],[],[]],[[[61],[51,"buildings",[-2],[0,"ba6Ebf17hXjZ3btyqFSu6a",-1,0]],[64,"Node-0",1,[[12,-3,[1,"0chJcn791fE68wJOV2bkqg"],[0,1],[4],2]],[0,"82GHh4unBQw4Z2qSZmD3ay",1,0]]],0,[0,2,1,0,-1,2,0,0,2,0,10,1,3],[0,0,0],[-1,-2,1],[155,156,157]],[[[11,".bin",1277898526,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":259776,"length":20832,"count":10416,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":289248,"length":540,"count":270,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":259776,"count":5412,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":280608,"length":8640,"count":180,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-142.78785705566406,0.22627797722816467,-136.5164337158203],"maxPosition",8,[1,138.89756774902344,51.948455810546875,139.72389221191406]]],-1],0,0,[],[],[]],[[[24,"sfx_hit_goalpost",".mp3",1.152],-1],0,0,[],[],[]],[[[24,"sfx_highpass",".mp3",0.496327],-1],0,0,[],[],[]],[[{"name":"grass","rect":{"x":0,"y":0,"width":177,"height":1254},"offset":{"x":0,"y":0},"originalSize":{"width":177,"height":1254},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[3],0,[0],[11],[158]],[[[24,"PlayWhistle",".mp3",0.287325],-1],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[4],0,[],[],[]],[[{"name":"TextureRestarbtn","rect":{"x":0,"y":0,"width":100,"height":100},"offset":{"x":0,"y":0},"originalSize":{"width":100,"height":100},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[3],0,[0],[11],[159]],[[[28,"player_red"],[47,"player_red",[[-3,-4,[48,"Dummy_ball",-6,[0,"e5ylxVKQVMAYxM9uFuk70D",-5,0]]],1,1,4],[[70,true,false,-2,[1,"57FGriRHBaGLpGiH9fJYnh"],[3,4,5,6,7,8,9,10,11,12,13,14,15]]],[0,"ff35WAxT1Ul7D6wG+gDQYZ",-1,0],[1,0,0,28],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[31,"Bip01 Pelvis",[-7,-8,-9],[0,"78Kk+weHFfdIMu8+FZwRiY",1,0],[1,-4.440891999238953e-18,-0.0011781406356021762,7.105427198782324e-17],[3,-0.4859049320220947,-0.4859057366847992,-0.51370769739151,0.5137084722518921],[1,-89.9999083366091,-89.99999808364298,-3.186371087618207]],[6,"Bip01 Spine",2,[-10,-11,-12],[0,"78+5TeXDxbN66ertwa0f5Q",1,0],[1,0.0056739808060228825,-0.0003261065576225519,0.0003165105008520186],[3,-0.02254779450595379,0.019818831235170364,0.2838953137397766,0.9583852291107178],[1,-0.0009237367740082856,5.627829881829226,14.494793129923595]],[31,"Bip01 L Hand",[-13,-14],[0,"d4KvSmIt5cT4ZApoebztzu",1,0],[1,0.2525566518306732,0,-7.105427198782324e-17],[3,-0.6497532725334167,-0.12915632128715515,-0.2877475917339325,0.691621720790863],[1,-90.58618681990082,-34.59922825000951,-13.30799222225321]],[31,"Bip01 R Hand",[-15,-16],[0,"a9Zk+FGNlbuKY70ycsirCi",1,0],[1,0.25255653262138367,-3.814697180359872e-8,0],[3,0.7975999712944031,0.03097526542842388,-0.1283959448337555,0.588548481464386],[1,97.6264653247762,33.19392588432115,-9.391751626957756]],[6,"Bip01",1,[2],[0,"23SOiLJlhTaa3n5VQuHara",1,0],[1,-0.0011760517954826355,0.6104837656021118,-0.0000408247287850827],[3,0.5306697487831116,-0.48900237679481506,-0.49252578616142273,-0.4865024983882904],[1,-92.77548259118844,87.90141570021434,-2.279110091991302]],[6,"Bip01 Neck",3,[-17],[0,"19tEG1Hn9eWY8yO2AcTwxD",1,0],[1,0.49215054512023926,0.004864883609116077,-0.000001274347255275643],[3,0.02096555009484291,-0.019034257158637047,-0.09327365458011627,0.9952377676963806],[1,4.862560102540894,2.2346847452485847,2.994144221877177]],[16,"Bip01 Head",7,[[23,"Bip01 HeadNub",-18,[0,"25mSQgTL1ZjYSXq6cJVTLf",1,0],[1,0.4308355748653412,-1.907348590179936e-8,4.76837147544984e-9]]],[0,"12bHt6QrhaSpUNWGc3Xldk",1,0],[1,0.03912590071558952,7.105427198782324e-17,-1.19209286886246e-9],[3,-0.01678335666656494,0.027794819325208664,-0.005603412631899118,0.999457061290741],[1,-16.891730533959947,-8.864735321331683,-15.87538668364434]],[6,"Bip01 L Clavicle",3,[-19],[0,"48S157hklcmZ5kzs8xIUQs",1,0],[1,0.45160847902297974,-0.012276687659323215,0.029130801558494568],[3,0.6508494019508362,0.09362103790044785,0.7489505410194397,0.08187314867973328],[1,-176.35781561858622,-103.86084828649889,15.139972216061024]],[6,"Bip01 L UpperArm",9,[-20],[0,"deYvatZuRaLrv68TukiBWf",1,0],[1,0.11830057203769684,7.629394360719743e-8,0],[3,0.1371213048696518,0.4749643802642822,0.0775243267416954,0.865792453289032],[1,9.28591958400456,41.95735168128716,13.861681617323258]],[6,"Bip01 L Forearm",10,[4],[0,"f8hTG4LZRbRphmpwRXdLLB",1,0],[1,0.25530532002449036,-7.629394360719743e-8,0],[3,3.9227432511216534e-17,1.3972907581198614e-18,-0.6814873218536377,0.7318299412727356],[1,4.776933213802346e-14,4.470206830942568e-14,-85.91997904757712]],[16,"Bip01 L Finger0",4,[[23,"Bip01 L Finger0Nub",-21,[0,"60TOZmlyNfbYBBv1HWNYu7",1,0],[1,0.10331199318170547,7.105427198782324e-17,0]]],[0,"58QZfQoZ1awqL+GHiYbr1q",1,0],[1,0.0721408873796463,3.814697180359872e-8,0],[3,-0.00039811438182368875,2.7750048394775834e-17,1.388883728643694e-17,0.9999999403953552],[1,-0.04562054978513868,3.1805547354345e-15,1.590277450444124e-15]],[16,"Bip01 L Finger1",4,[[23,"Bip01 L Finger1Nub",-22,[0,"c8CPb7A+tXlL6fNdNRgkJI",1,0],[1,0.10687562823295593,0,0]]],[0,"a7dR9SkIZYBajY66udFPK8",1,0],[1,0.0716785416007042,0.0006313705234788358,0.021634826436638832],[3,-0.00039811438182368875,2.7750048394775834e-17,1.388883728643694e-17,0.9999999403953552],[1,-0.04562395975208181,0.0000017075472034329276,-8.537736208213878e-7]],[6,"Bip01 R Clavicle",3,[-23],[0,"c1BytVJrpW9IlMhkwyHjh6",1,0],[1,0.45160847902297974,-0.01227645855396986,-0.029130874201655388],[3,-0.6288012266159058,-0.09060851484537125,0.7686547040939331,0.07462635636329651],[1,-179.18836425087892,92.44080615224583,-18.336690610480556]],[6,"Bip01 R UpperArm",14,[-24],[0,"eckBF0AhJbKKttt28luY8z",1,0],[1,0.11830054968595505,0,1.4210854397564648e-16],[3,0.09451285749673843,-0.5099676251411438,0.2040395587682724,0.8302819728851318],[1,-34.456376758617324,-41.337078790439286,33.81003271413883]],[6,"Bip01 R Forearm",15,[5],[0,"9bFaYqyChfY59Alb4jBscY",1,0],[1,0.25530529022216797,3.814697180359872e-8,-7.105427198782324e-17],[3,-1.8817387825542242e-17,-7.427390377734094e-18,-0.6087151169776917,0.7933889031410217],[1,-180,-180,-68.76107840101615]],[16,"Bip01 R Finger0",5,[[30,"Bip01 R Finger0Nub",-25,[0,"e3rvwV0y1Sm6hugWhYmEHq",1,0],[1,0.10331205278635025,-3.814697180359872e-8,-3.814697180359872e-8],[3,-1.1102230246251565e-16,-7.450580596923828e-9,1,6.123233601181349e-17],[1,-1,-1,-1],[1,-180,-179.99999914622634,-7.0167096047110005e-15]]],[0,"fdjhHGBLVRHqqHKfsq5KHF",1,0],[1,0.07214086502790451,-7.105427198782324e-17,3.814697180359872e-8],[3,0.0003981367335654795,-1.4901160305669237e-8,5.9327412774146104e-12,0.9999999403953552],[1,0.04562224886991161,-8.537736208172892e-7,-8.537736207970288e-7]],[16,"Bip01 R Finger1",5,[[30,"Bip01 R Finger1Nub",-26,[0,"baiqamLjBQz5RKMZCgQBsm",1,0],[1,0.10687566548585892,0,0],[3,9.124330077954887e-25,-1.4901161193847656e-8,1,-6.123234262925839e-17],[1,-1,-1,-1],[1,180,179.99999914622634,-8.537736462515939e-7]]],[0,"d8C7mOY3lXm5UHPXUIChkl",1,0],[1,0.071678526699543,0.0006313705234788358,-0.021634865552186966],[3,0.0003981590853072703,-1.4901160305669237e-8,5.933074344321998e-12,0.9999999403953552],[1,0.045625663964158805,-8.537735953627242e-7,-8.537736462313321e-7]],[6,"Bip01 L Thigh",2,[-27],[0,"06//swxr5du4krd2hgb5l5",1,0],[1,-1.9073486612342094e-7,1.4781952017983713e-7,0.1258874386548996],[3,0.390167772769928,0.9193310141563416,0.01911548338830471,-0.04726693779230118],[1,-7.327965175591944,-170.05317385124434,-16.228344923236463]],[6,"Bip01 L Calf",19,[-28],[0,"141Joly0peo7qYaqpozJAT",1,0],[1,0.3375164866447449,7.105427198782324e-17,0],[3,2.399468150100959e-18,-2.505914921203111e-18,-0.7222809195518494,0.6915997862815857],[1,2.385416263074054e-15,7.855124317273805e-24,-36.329899104889755]],[6,"Bip01 L Foot",20,[-29],[0,"12F9BLnbFahomhselvozdM",1,0],[1,0.25808095932006836,1.907348590179936e-8,1.907348590179936e-8],[3,-0.035022199153900146,0.058264460414648056,0.3034195899963379,0.9504289627075195],[1,3.7657200527503165,-5.451189556921288,9.705714728893218]],[16,"Bip01 L Toe0",21,[[30,"Bip01 L Toe0Nub",-30,[0,"feDJEeu6tU84jN2td5CXas",1,0],[1,0.13195955753326416,4.76837147544984e-9,1.907348590179936e-8],[3,5.204170427930421e-18,7.450580596923828e-9,1,-6.123234262925839e-17],[1,-0.9999999403953552,-1,-1],[1,-179.9999997865566,-179.9999993863502,8.537736473946058e-7]]],[0,"e6KoGOnZhc6IllXqapHTlV",1,0],[1,0.10668583959341049,0.18787609040737152,-1.907348590179936e-8],[3,-3.924926375020732e-7,4.1356591395924625e-7,0.7071069478988647,0.7071066498756409],[1,178.93671737938615,179.3093883490468,63.696444692646544]],[6,"Bip01 R Thigh",2,[-31],[0,"63YoYbwihfVq+C1uJb1ubA",1,0],[1,1.5258788721439487e-7,-2.0027160019253643e-7,-0.1258874535560608],[3,0.3489620089530945,0.9298656582832336,-0.09755171090364456,0.06371044367551804],[1,8.49661779274763,-175.88996697436087,22.76528046580491]],[6,"Bip01 R Calf",23,[-32],[0,"d7AoqkFvBRSYr1NLXpzFqG",1,0],[1,0.3375164866447449,0,-1.907348590179936e-8],[3,4.210066422125418e-17,-1.2388041314870742e-17,-0.5711630582809448,0.82083660364151],[1,180,180,-67.8917940965223]],[6,"Bip01 R Foot",24,[-33],[0,"243XxYtCxegK+dy/qNdun+",1,0],[1,0.2580810785293579,2.3841858265427618e-8,9.53674295089968e-9],[3,-0.09684641659259796,-0.003290298394858837,0.22763356566429138,0.9689132571220398],[1,4.089481092363769,11.714621432387062,15.258506239142363]],[16,"Bip01 R Toe0",25,[[23,"Bip01 R Toe0Nub",-34,[0,"c7Q00V9XJQ35bdhmC54uG4",1,0],[1,0.13195957243442535,1.19209286886246e-9,-3.552713599391162e-17]]],[0,"5cLoA5EsFavIlrolfDjTNK",1,0],[1,0.10668586939573288,0.1878761351108551,-1.907348590179936e-8],[3,-0.000035561428376240656,0.0000339990365318954,0.7220386266708374,0.6918527483940125],[1,179.99060378085323,179.97753714721676,87.03208521643715]],[10,"player_uniform_lod0",1,[[54,1,-35,[1,"f5E/zK38hWx7N0DvHJ2ykh"],[0],[4],1,1,2]],[0,"c5E76aQ+1bt5PAvFsp8p+o",1,0],[1,2.551235889214354e-9,2.551235889214354e-9,-0.05836546793580055],[3,-0.7071067690849304,0,0,0.7071067690849304],[1,-90.00000000000003,0,0]]],0,[0,2,1,0,0,1,0,-1,6,0,-2,27,0,2,1,0,3,1,0,-1,3,0,-2,19,0,-3,23,0,-1,7,0,-2,9,0,-3,14,0,-1,12,0,-2,13,0,-1,17,0,-2,18,0,-1,8,0,3,8,0,-1,10,0,-1,11,0,3,12,0,3,13,0,-1,15,0,-1,16,0,3,17,0,3,18,0,-1,20,0,-1,21,0,-1,22,0,3,22,0,-1,24,0,-1,25,0,-1,26,0,3,26,0,0,27,0,10,1,2,3,6,4,3,11,5,3,16,35],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,1,13,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13],[27,16,17,18,21,28,29,10,19,20,30,31,32,33,34,35]],[[[33,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{"USE_LIGHTMAP":true},{},{},{}],[[[{},"mainColor",8,[4,4278190218],"emissive",8,[4,4278190141]],{},{},{}],11,0,0,0]]],0,0,[0],[6],[0]],[[{"name":"grassmask","rect":{"x":0,"y":0,"width":4,"height":684},"offset":{"x":0,"y":0},"originalSize":{"width":4,"height":684},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[3],0,[0],[11],[160]]]]
